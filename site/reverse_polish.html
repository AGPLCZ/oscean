<!DOCTYPE html><html lang='en'></head><meta charset='utf-8'><meta name='description' content='In Reverse Polish Notation, the operators follow their operands.'/><meta name='thumbnail' content='https://wiki.xxiivv.com/media/services/thumbnail.jpg' /><meta name='viewport' content='width=device-width,initial-scale=1'><link rel='alternate' type='application/rss+xml' title='RSS Feed' href='../links/rss.xml' /><link rel='stylesheet' type='text/css' href='../links/main.css'><link rel='shortcut icon' type='image/png' href='../media/services/icon.png'><title>XXIIVV — reverse polish</title></head><body><header><a href='home.html'><img src='../media/services/logo.png' alt='XXIIVV' height='29'></a></header><nav><ul><li><a href='binary.html'>binary</a></li><li><a href='assembly.html'>assembly</a></li><li><a href='forth.html'>forth/</a></li><li><a href='pascal.html'>pascal</a></li><li><a href='hypertalk.html'>hypertalk</a></li><li><a href='unix.html'>unix</a></li><li><a href='postscript.html'>postscript</a></li></ul><ul><li><a href='reverse_polish.html'>reverse polish/</a></li></ul><ul></ul></nav><main><h2>In Reverse Polish Notation, the operators follow their operands.</h2><p>For instance, one would write <code>3 4 +</code> rather than <code>3 + 4</code>. If there are multiple operations, operators are given immediately after their second operands. The expression written <code>(5 + 10) * 3</code> in conventional notation would be written <code>3 10 5 + *</code> in reverse Polish notation.</p><table border='1'><tr><td><i>operation</i></td><th>3</th><th>10</th><th>5</th><th>+</th><th>*</th></tr><tr><td rowspan='3'><i>stack</i></td><td rowspan='3'>3</td><td>10</td><td>5</td><td>15</td><td rowspan='3'>45</td></tr><tr><td rowspan='2'>3</td><td>10</td><td rowspan='2'>3</td></tr><tr><td>3</td></tr></table><p>The automatic stack permits the automatic storage of intermediate results for use later: this key feature is what permits RPN calculators to easily evaluate expressions of arbitrary complexity: they do not have limits on the complexity of expression they can evaluate.</p><p>Brackets and parentheses are unnecessary: the user simply performs calculations in the order that is required, letting the automatic stack store intermediate results on the fly for later use. Likewise, there is no requirement for the precedence rules required in infix notation.</p><p>In RPN calculators, no equals key is required to force computation to occur. To learn more about a programming language using RPN at its core, see <a href='forth.html'>Forth</a>.</p><h3>Simple ANSI C implementation</h3><pre>./rpn 2 3 4 5 add mul sub 5 div <i># 45</i></pre><figure><pre>#include &lt;stdio.h&gt;

#define SSZ 256
#define QSZ 32

typedef struct Fraction {
	int num;
	int den;
} Fraction;

typedef struct Stack {
	Fraction data[SSZ];
	int len;
} Stack;

typedef struct Query {
	char data[QSZ];
	int len;
} Query;

/* helpers */

int
cinu(char c)
{
	return c &gt;= '0' &amp;&amp; c &lt;= '9';
}

int
sinu(char *s)
{
	int i = 0;
	if(!s[0])
		return 0;
	while(s[i])
		if(!cinu(s[i++]))
			return 0;
	return 1;
}

int
sint(char *s)
{
	int i = 0, num = 0;
	while(s[i] &amp;&amp; cinu(s[i]))
		num = num * 10 + (s[i++] - '0');
	return num;
}

int
scmp(char *a, char *b)
{
	int i = 0;
	while(a[i] == b[i])
		if(!a[i++])
			return 1;
	return 0;
}

int
gcd(int a, int b)
{
	if(b == 0)
		return a;
	return gcd(b, a % b);
}

void
init(Query *s)
{
	s-&gt;data[0] = '\0';
	s-&gt;len = 0;
}

void
append(Query *s, char c)
{
	if(s-&gt;len &lt; QSZ)
		s-&gt;data[s-&gt;len++] = c;
	s-&gt;data[s-&gt;len] = '\0';
}

Fraction *
reduce(Fraction *f)
{
	int d = gcd(f-&gt;num, f-&gt;den);
	f-&gt;num /= d;
	f-&gt;den /= d;
	return f;
}

/* rpn */

int
error(char *err)
{
	printf("Error: %s\n", err);
	return 0;
}

int
trypop(Stack *s, int len)
{
	int err = s-&gt;len - len &lt; 0;
	if(err)
		error("Stack underflow");
	return !err;
}

int
trypush(Stack *s, int len)
{
	int err = s-&gt;len + len &gt;= SSZ;
	if(err)
		error("Stack overflow");
	return !err;
}

Fraction
pop(Stack *s)
{
	return s-&gt;data[--s-&gt;len];
}

Fraction *
push(Stack *s, int num, int den)
{
	s-&gt;data[s-&gt;len].num = num;
	s-&gt;data[s-&gt;len].den = den;
	return reduce(&amp;s-&gt;data[s-&gt;len++]);
}

void
print(Stack *s, int decimals)
{
	int i;
	if(s-&gt;len &lt; 1)
		return;
	for(i = 0; i &lt; s-&gt;len; ++i) {
		if(decimals)
			printf("%.4f", s-&gt;data[i].num / (double)s-&gt;data[i].den);
		else if(s-&gt;data[i].den != 1)
			printf("%d/%d ", s-&gt;data[i].num, s-&gt;data[i].den);
		else
			printf("%d ", s-&gt;data[i].num);
	}
	printf("\n");
}

/* ops */

void
request(Stack *s, char *qd)
{
	if(qd[0] == ' ' || qd[0] == '.' || qd[0] == '\0')
		print(s, 0);
	else if(qd[0] == '!')
		print(s, 1);
	else if(sinu(qd) &amp;&amp; trypush(s, 1))
		push(s, sint(qd), 1);
	else if(scmp(qd, "pop") &amp;&amp; trypop(s, 1))
		pop(s);
	else if(scmp(qd, "dup") &amp;&amp; trypop(s, 1) &amp;&amp; trypush(s, 1)) {
		Fraction b = pop(s);
		push(s, b.num, b.den);
		push(s, b.num, b.den);
	} else if(scmp(qd, "swp") &amp;&amp; trypop(s, 2)) {
		Fraction b = pop(s);
		Fraction a = pop(s);
		push(s, b.num, b.den);
		push(s, a.num, a.den);
	} else if((scmp(qd, "add") || qd[0] == '+') &amp;&amp; trypop(s, 2)) {
		Fraction b = pop(s);
		Fraction a = pop(s);
		push(s, (a.num * b.den) + (a.den * b.num), a.den * b.den);
	} else if((scmp(qd, "sub") || qd[0] == '-') &amp;&amp; trypop(s, 2)) {
		Fraction b = pop(s);
		Fraction a = pop(s);
		push(s, (a.num * b.den) - (a.den * b.num), a.den * b.den);
	} else if((scmp(qd, "mul") || qd[0] == '*') &amp;&amp; trypop(s, 2)) {
		Fraction b = pop(s);
		Fraction a = pop(s);
		push(s, a.num * b.num, a.den * b.den);
	} else if((scmp(qd, "div") || qd[0] == '/') &amp;&amp; trypop(s, 2)) {
		Fraction b = pop(s);
		Fraction a = pop(s);
		push(s, a.num * b.den, a.den * b.num);
	}
}

int
run(Stack *s)
{
	char c;
	Query q;
	init(&amp;q);
	while((c = fgetc(stdin)) != EOF) {
		if(c == ' ' || c == '\n' || !c) {
			request(s, q.data);
			init(&amp;q);
		} else
			append(&amp;q, c);
	}
	return 0;
}

int
main()
{
	Stack s;
	s.len = 0;
	while(run(&amp;s))
		;
	print(&amp;s, 0);
	return 0;
}</pre><figcaption>&mdash; Found a mistake? Submit an <a href='https://github.com/XXIIVV/oscean/blob/master/src/inc/text/rpn.c.txt' target='_blank'>edit</a> to <a href='../src/inc/text/rpn.c.txt'>rpn.c.txt</a>(215 lines)</figcaption>
</figure><ul><li><a href='https://git.sr.ht/~rabbits/firth' target='_blank'>Firth</a></li></ul><p><i>incoming(2)</i>: <a href='forth.html'>forth</a> <a href='postscript.html'>postscript</a> </p><p><i>Last update on <a href='tracker.html'>20V06</a>, edited 5 times. +14/19fh</i><code style='float:right; font-size:80%'>-----+</code></p></main><footer><a href='https://creativecommons.org/licenses/by-nc-sa/4.0'><img src='../media/icon/cc.svg' width='30'/></a><a href='http://webring.xxiivv.com/'><img src='../media/icon/rotonde.svg' width='30'/></a><a href='https://merveilles.town/@neauoire'><img src='../media/icon/merveilles.svg' width='30'/></a><a href='https://github.com/neauoire'><img src='../media/icon/github.png' alt='github' width='30'/></a><span><a href='devine_lu_linvega.html'>Devine Lu Linvega</a> © 2020 — <a href='about.html'>BY-NC-SA 4.0</a></span></footer></body></html>