<!DOCTYPE html><html lang='en'></head><meta charset='utf-8'><meta name='description' content='Moogle is a 3D wireframe toolkit.'/><meta name='thumbnail' content='https://wiki.xxiivv.com/media/services/thumbnail.jpg' /><meta name='viewport' content='width=device-width,initial-scale=1'><link rel='alternate' type='application/rss+xml' title='RSS Feed' href='../links/rss.xml' /><link rel='stylesheet' type='text/css' href='../links/main.css'><link rel='shortcut icon' type='image/png' href='../media/services/icon.png'><title>XXIIVV — moogle</title></head><body><header><a href='home.html'><img src='../media/identity/xiv28.gif' alt='XXIIVV' height='29'></a></header><nav><ul><li><a href='tools.html'>tools/</a></li><li><a href='utilities.html'>utilities</a></li><li><a href='games.html'>games</a></li><li><a href='mobile.html'>mobile</a></li><li><a href='automatons.html'>automatons</a></li></ul><ul><li><a href='ronin.html'>ronin</a></li><li><a href='dotgrid.html'>dotgrid</a></li><li><a href='left.html'>left</a></li><li><a href='nasu.html'>nasu</a></li><li><a href='moogle.html'>moogle/</a></li></ul><ul></ul></nav><main><figure><img src='../media/diary/727.jpg' alt='Pitch Yaw Roll picture' width='900'/><figcaption>20P12 — Pitch Yaw Roll</figcaption></figure><h2>Moogle is a 3D wireframe toolkit.</h2><p>Moogle is a minimal <b>3D wireframe tool</b> designed to be used alongside its companion tool <a href='nasu.html'>Nasu</a>. It offers a handful of basic geometry drawing functions, it was written in <a href='ansi_c.html'>ANSI C</a>, and was inspired by <a href='graf3dscene.html'>Graf3DScene</a>.</p><p>Both Moogle and Nasu exports to the <a href='chr_format.html'>chr format</a>.</p><h3>moogle.c</h3><p>To control the window size and default colors, edit the values defined at the top of the file itself. Press , <code>E</code> to export a <code>.chr</code> file, press <code>R</code> to render a <code>.bmp</code> file, and press <code>h</code> to toggle tile guides. To learn more, visit the <a href='https://git.sr.ht/~rabbits/moogle' target='_blank'>repository</a>.</p><pre>sudo apt-get install libsdl2-dev</pre><p>The following code is a single-file implementation written in 700 lines of <a href='ansi_c.html'>ANSI C</a>, the only dependecy is <a href='https://www.libsdl.org' target='_blank'>SDL2</a>.</p><pre>cc -std=c89 -Wall moogle.c -I/usr/local/include -L/usr/local/lib -lSDL2 -lm -o moogle</pre><figure><pre>#include &lt;SDL2/SDL.h&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

#define HOR 16
#define VER 16
#define PAD 8
#define ZOOM 4
#define color1 0xFFFFFF
#define color2 0x000000
#define color3 0x72DEC2
#define color4 0xAAAAAA
#define color0 0xEFEFEF

#define SZ (HOR * VER * 16)
#define PI 3.14159265358979323846

typedef struct {
	int x, y;
} Point;

typedef struct {
	double x, y;
} Point2d;

typedef struct {
	double x, y, z;
} Point3d;

typedef struct {
	int a, b;
} Edge;

typedef struct {
	Point3d position, vertices[128];
	Edge edges[128];
	int verticeslen, edgeslen, color;
} Mesh;

typedef struct {
	Point3d origin;
	Mesh meshes[128];
	int len;
} Scene;

typedef enum {
	ISOMETRIC,
	PERSPECTIVE
} Projection;

typedef struct {
	Projection projection;
	double pitch, yaw, roll;
} Camera;

Scene scn;
Camera cam;

unsigned char chrbuf[SZ];
int colors[] = {color1, color2, color3, color4, color0};
int WIDTH = 8 * HOR + PAD * 2;
int HEIGHT = 8 * VER + PAD * 2;
int FPS = 30;
int GUIDES = 0;
SDL_Window* gWindow = NULL;
SDL_Renderer* gRenderer = NULL;
SDL_Texture* gTexture = NULL;
uint32_t* pixels;

Point
Pt(int x, int y)
{
	Point p;
	p.x = x;
	p.y = y;
	return p;
}

Point2d
Pt2d(double x, double y)
{
	Point2d p;
	p.x = x;
	p.y = y;
	return p;
}

Point3d
Pt3d(double x, double y, double z)
{
	Point3d p;
	p.x = x;
	p.y = y;
	p.z = z;
	return p;
}

Mesh
Ms3d(double x, double y, double z)
{
	Mesh m;
	m.position = Pt3d(x, y, z);
	m.verticeslen = 0;
	m.edgeslen = 0;
	m.color = 2;
	return m;
}

Scene
Sc3d(double x, double y, double z)
{
	Scene s;
	s.origin = Pt3d(x, y, z);
	s.len = 0;
	return s;
}

Camera
Cm3d(double pitch, double yaw, double roll)
{
	Camera c;
	c.pitch = pitch;
	c.yaw = yaw;
	c.roll = roll;
	c.projection = PERSPECTIVE;
	return c;
}

/* geometry */

double
rad2deg(double rad)
{
	return rad * (180 / PI);
}

double
deg2rad(double deg)
{
	return deg * (PI / 180);
}

double
ptangledeg(Point2d a, Point2d b)
{
	return rad2deg(atan2(b.y - a.y, b.x - a.x));
}

double
ptangle(Point2d a, Point2d b)
{
	return atan2(b.y - a.y, b.x - a.x);
}

double
ptdistance(Point2d a, Point2d b)
{
	double x = a.x - b.x;
	double y = a.y - b.y;
	return sqrt(x * x + y * y);
}

Point2d
rotpt(Point2d c, Point2d p0, double deg)
{
	double rot = ptangle(c, p0) + deg2rad(deg);
	double r = ptdistance(c, p0);
	return Pt2d(c.x + r * cos(rot), c.y + r * sin(rot));
}

/* scene */

void
setvertex(Point3d* v, double x, double y, double z)
{
	v-&gt;x = x;
	v-&gt;y = y;
	v-&gt;z = z;
}

void
addvertex(Mesh* m, double x, double y, double z)
{
	setvertex(&amp;m-&gt;vertices[m-&gt;verticeslen], x, y, z);
	m-&gt;verticeslen++;
}

void
setedge(Edge* e, int v0, int v1)
{
	e-&gt;a = v0;
	e-&gt;b = v1;
}

void
addedge(Mesh* m, int v0, int v1)
{
	setedge(&amp;m-&gt;edges[m-&gt;edgeslen], v0, v1);
	m-&gt;edgeslen++;
}

void
addmesh(Scene* s, Mesh m)
{
	s-&gt;meshes[s-&gt;len] = m;
	s-&gt;len++;
}

void
rotverx(Point3d* o, Point3d* v, double angle)
{
	Point2d r = rotpt(Pt2d(o-&gt;y, o-&gt;z), Pt2d(v-&gt;y, v-&gt;z), angle);
	v-&gt;y = r.x;
	v-&gt;z = r.y;
}

void
rotvery(Point3d* o, Point3d* v, double angle)
{
	Point2d r = rotpt(Pt2d(o-&gt;x, o-&gt;z), Pt2d(v-&gt;x, v-&gt;z), angle);
	v-&gt;x = r.x;
	v-&gt;z = r.y;
}

void
rotverz(Point3d* o, Point3d* v, double angle)
{
	Point2d r = rotpt(Pt2d(o-&gt;x, o-&gt;y), Pt2d(v-&gt;x, v-&gt;y), angle);
	v-&gt;x = r.x;
	v-&gt;y = r.y;
}

void
rotver(Point3d* o, Point3d* v, double pitch, double yaw, double roll)
{
	rotverx(o, v, pitch);
	rotvery(o, v, yaw);
	rotverz(o, v, roll);
}

void
rotatex(Mesh* m, double angle)
{
	int i;
	for(i = 0; i &lt; m-&gt;verticeslen; i++)
		rotverx(&amp;m-&gt;position, &amp;m-&gt;vertices[i], angle);
}

void
rotatey(Mesh* m, double angle)
{
	int i;
	for(i = 0; i &lt; m-&gt;verticeslen; i++)
		rotvery(&amp;m-&gt;position, &amp;m-&gt;vertices[i], angle);
}

void
rotatez(Mesh* m, double angle)
{
	int i;
	for(i = 0; i &lt; m-&gt;verticeslen; i++)
		rotverz(&amp;m-&gt;position, &amp;m-&gt;vertices[i], angle);
}

void
rotate(Mesh* m, double x, double y, double z)
{
	rotatex(m, x);
	rotatey(m, y);
	rotatez(m, z);
}

Point3d
addpt3d(Point3d* a, Point3d* b)
{
	return Pt3d(a-&gt;x + b-&gt;x, a-&gt;y + b-&gt;y, a-&gt;z + b-&gt;z);
}

Point
project(Camera* c, Point3d v)
{
	double r;
	if(c-&gt;projection == ISOMETRIC)
		return Pt(WIDTH / 2 * v.x, HEIGHT / 2 * v.y);
	r = 300 / (v.z + 50);
	return Pt(WIDTH / 2 + r * v.x, HEIGHT / 2 + r * v.y);
}

void
extrude(Mesh* m, double depth)
{
	int i, vl = m-&gt;verticeslen, el = m-&gt;edgeslen;
	for(i = 0; i &lt; vl; i++) {
		addvertex(m,
		          m-&gt;vertices[i].x,
		          m-&gt;vertices[i].y,
		          m-&gt;vertices[i].z + depth);
		addedge(m, i, i + vl);
	}
	for(i = 0; i &lt; el; i++)
		addedge(m,
		        m-&gt;edges[i].a + vl,
		        m-&gt;edges[i].b + vl);
}

void
symmetry(Mesh* m, double x, double y, double z)
{
	int i, el, vl = m-&gt;verticeslen;
	for(i = 0; i &lt; vl; i++)
		addvertex(m,
		          m-&gt;vertices[i].x * x,
		          m-&gt;vertices[i].y * y,
		          m-&gt;vertices[i].z * z);
	el = m-&gt;edgeslen;
	for(i = 0; i &lt; el; i++)
		addedge(m,
		        el + 1 + m-&gt;edges[i].a,
		        el + 1 + m-&gt;edges[i].b);
}

void
addpoly(Mesh* m, double x, double y, double z, double radius, int segments)
{
	int i, offset = m-&gt;verticeslen;
	for(i = 0; i &lt; segments; i++) {
		addvertex(m,
		          x + radius * cos(2 * PI * i / segments),
		          y + radius * sin(2 * PI * i / segments),
		          z);
		addedge(m, offset + i, offset + (i + 1) % segments);
	}
}

void
addpolygon(Scene* s, double x, double y, double z, double radius, int segments)
{
	Mesh m = Ms3d(x, y, z);
	addpoly(&amp;m, x, y, z, radius, segments);
	addmesh(s, m);
}

void
addpyramid(Scene* s, double x, double y, double z, double radius, int segments, double depth)
{
	int i;
	Mesh m = Ms3d(x, y, z);
	addpoly(&amp;m, x, y, z - depth / 2, radius, segments);
	addvertex(&amp;m, x, y, z + depth / 2);
	for(i = 0; i &lt; segments; i++)
		addedge(&amp;m, i, segments);
	addmesh(s, m);
}

void
addfrustum(Scene* s, double x, double y, double z, double radius, int segments, double depth, double mod)
{
	int i;
	Mesh m = Ms3d(x, y, z);
	addpoly(&amp;m, x, y, z - depth / 2, radius, segments);
	addpoly(&amp;m, x, y, z + depth / 2, radius * mod, segments);
	for(i = 0; i &lt; segments; i++)
		addedge(&amp;m, i, segments + i);
	addmesh(s, m);
}

void
addprism(Scene* s, double x, double y, double z, double radius, int segments, double depth)
{
	Mesh m = Ms3d(x, y, z);
	addpoly(&amp;m, x, y, z - depth / 2, radius, segments);
	extrude(&amp;m, depth);
	addmesh(s, m);
}

int
row(int x, int y)
{
	return (y % 8) + ((x / 8 + y / 8 * HOR) * 16);
}

int
get(int x, int y)
{
	int ch1, ch2;
	int r = row(x, y);
	int px = x % 8;
	if(r &lt; 0 || r &gt; SZ - 8)
		return 0;
	ch1 = (chrbuf[r] &gt;&gt; (7 - px)) &amp; 1;
	ch2 = (chrbuf[r + 8] &gt;&gt; (7 - px)) &amp; 1;
	return ch1 &amp;&amp; !ch2 ? 1 : !ch1 &amp;&amp; ch2 ? 2 : ch1 &amp;&amp; ch2 ? 3 : 0;
}

void
put(int x, int y, int color)
{
	int r = row(x, y);
	int px = x % 8;
	if(x &lt; 0 || y &lt; 0 || x &gt; 8 * HOR || y &gt; 8 * VER || r &gt; SZ - 8)
		return;
	if(color == 0) {
		chrbuf[r] &amp;= ~(1UL &lt;&lt; (7 - px));
		chrbuf[r + 8] &amp;= ~(1UL &lt;&lt; (7 - px));
	} else if(color == 2) {
		chrbuf[r] |= 1UL &lt;&lt; (7 - px);
		chrbuf[r + 8] &amp;= ~(1UL &lt;&lt; (7 - px));
	} else if(color == 1) {
		chrbuf[r] &amp;= ~(1UL &lt;&lt; (7 - px));
		chrbuf[r + 8] |= 1UL &lt;&lt; (7 - px);
	} else if(color == 3) {
		chrbuf[r] |= 1UL &lt;&lt; (7 - px);
		chrbuf[r + 8] |= 1UL &lt;&lt; (7 - px);
	}
}

void
line(Point p0, Point p1, int color)
{
	double dx = abs(p1.x - p0.x), sx = p0.x &lt; p1.x ? 1 : -1;
	double dy = -abs(p1.y - p0.y), sy = p0.y &lt; p1.y ? 1 : -1;
	double err = dx + dy, e2;
	for(;;) {
		put(p0.x, p0.y, color);
		if(p0.x == p1.x &amp;&amp; p0.y == p1.y)
			break;
		e2 = 2 * err;
		if(e2 &gt;= dy) {
			err += dy;
			p0.x += sx;
		}
		if(e2 &lt;= dx) {
			err += dx;
			p0.y += sy;
		}
	}
}

void
edit(uint32_t* dst, int id, int color)
{
	int ti = id / 64;
	int odd = (ti + (ti / HOR + 2)) % 2 == 0;
	int px = (ti / (HOR * VER)) * (8 * HOR) + (ti % HOR) * 8 + (id % 8);
	int py = ((ti / HOR) * 8) + ((id % 64) / 8);
	dst[(py + PAD) * WIDTH + (px + PAD)] = colors[GUIDES &amp;&amp; odd &amp;&amp; color == 0 ? 4 : color];
}

void
redraw(uint32_t* dst)
{
	int b, i, j, id = 0;
	for(b = 0; b &lt; SZ; b += 16)
		for(i = 0; i &lt; 8; i++)
			for(j = 7; j &gt;= 0; j--) {
				int ch1 = chrbuf[b + i];
				int ch2 = chrbuf[b + i + 8];
				int color = ((ch1 &gt;&gt; j) &amp; 0x1) + (((ch2 &gt;&gt; j) &amp; 0x1) &lt;&lt; 1);
				edit(dst, id, color);
				id++;
			}
	SDL_UpdateTexture(gTexture, NULL, dst, WIDTH * sizeof(uint32_t));
	SDL_RenderClear(gRenderer);
	SDL_RenderCopy(gRenderer, gTexture, NULL, NULL);
	SDL_RenderPresent(gRenderer);
}

void
render(Scene* s, Camera* c)
{
	int i, j;
	clear();
	for(i = 0; i &lt; s-&gt;len; i++) {
		Mesh* mesh = &amp;s-&gt;meshes[i];
		for(j = 0; j &lt; mesh-&gt;edgeslen; j++) {
			Edge* edge = &amp;mesh-&gt;edges[j];
			Point3d a = addpt3d(&amp;mesh-&gt;vertices[edge-&gt;a], &amp;mesh-&gt;position);
			Point3d b = addpt3d(&amp;mesh-&gt;vertices[edge-&gt;b], &amp;mesh-&gt;position);
			rotver(&amp;s-&gt;origin, &amp;a, c-&gt;pitch, c-&gt;yaw, c-&gt;roll);
			rotver(&amp;s-&gt;origin, &amp;b, c-&gt;pitch, c-&gt;yaw, c-&gt;roll);
			line(project(c, a), project(c, b), mesh-&gt;color);
		}
	}
	redraw(pixels);
}

void
orient(Scene* s, Camera* c, double pitch, double yaw, double roll)
{
	c-&gt;pitch = pitch;
	c-&gt;yaw = yaw;
	c-&gt;roll = roll;
	render(s, c);
}

void
orbit(Scene* s, Camera* c, Point drag)
{
	c-&gt;pitch -= drag.y / 3.0;
	c-&gt;yaw -= drag.x / 3.0;
	render(s, c);
}

void
toggleprojection(Scene* s, Camera* c)
{
	c-&gt;projection = c-&gt;projection == ISOMETRIC ? PERSPECTIVE : ISOMETRIC;
	render(s, c);
}

void
update(void)
{
	char title[512];
	snprintf(title, 512, "moogle [%d:%dx%d]",
	         HOR,
	         VER,
	         ZOOM);
	SDL_SetWindowTitle(gWindow, title);
}

int
error(char* msg, const char* err)
{
	printf("Error %s: %s\n", msg, err);
	return 0;
}

void
clear(void)
{
	int i;
	for(i = 0; i &lt; SZ; ++i)
		chrbuf[i] = 0x00;
}

void
tochr()
{
	FILE* f = fopen("export.chr", "wb");
	if(!fwrite(chrbuf, sizeof(chrbuf), 1, f))
		error("Save", "Invalid output file");
	fclose(f);
}

void
tobmp(void)
{
	SDL_Surface* surface = SDL_GetWindowSurface(gWindow);
	GUIDES = 0;
	redraw(pixels);
	SDL_RenderReadPixels(gRenderer,
	                     NULL,
	                     SDL_PIXELFORMAT_ARGB8888,
	                     surface-&gt;pixels,
	                     surface-&gt;pitch);
	SDL_SaveBMP(surface, "render.bmp");
	SDL_FreeSurface(surface);
}

void
quit(void)
{
	free(pixels);
	SDL_DestroyTexture(gTexture);
	gTexture = NULL;
	SDL_DestroyRenderer(gRenderer);
	gRenderer = NULL;
	SDL_DestroyWindow(gWindow);
	gWindow = NULL;
	SDL_Quit();
	exit(0);
}

void
dokey(SDL_Event* event)
{
	switch(event-&gt;key.keysym.sym) {
	case SDLK_ESCAPE:
		quit();
		break;
	case SDLK_e:
		tochr();
		break;
	case SDLK_r:
		tobmp();
		break;
	case SDLK_h:
		GUIDES = !GUIDES;
		redraw(pixels);
		break;
	case SDLK_w:
		cam.pitch += 3.0;
		render(&amp;scn, &amp;cam);
		break;
	case SDLK_a:
		cam.yaw -= 3.0;
		render(&amp;scn, &amp;cam);
		break;
	case SDLK_s:
		cam.pitch -= 3.0;
		render(&amp;scn, &amp;cam);
		break;
	case SDLK_d:
		cam.yaw += 3.0;
		render(&amp;scn, &amp;cam);
		break;
	}
	update();
}

int
init(void)
{
	int i, j;
	if(SDL_Init(SDL_INIT_VIDEO) &lt; 0)
		return error("Init", SDL_GetError());
	gWindow = SDL_CreateWindow("moogle",
	                           SDL_WINDOWPOS_UNDEFINED,
	                           SDL_WINDOWPOS_UNDEFINED,
	                           WIDTH * ZOOM,
	                           HEIGHT * ZOOM,
	                           SDL_WINDOW_SHOWN);
	if(gWindow == NULL)
		return error("Window", SDL_GetError());
	gRenderer = SDL_CreateRenderer(gWindow, -1, 0);
	if(gRenderer == NULL)
		return error("Renderer", SDL_GetError());
	gTexture = SDL_CreateTexture(gRenderer,
	                             SDL_PIXELFORMAT_ARGB8888,
	                             SDL_TEXTUREACCESS_STATIC,
	                             WIDTH,
	                             HEIGHT);
	if(gTexture == NULL)
		return error("Texture", SDL_GetError());
	pixels = (uint32_t*)malloc(WIDTH * HEIGHT * sizeof(uint32_t));
	if(pixels == NULL)
		return error("Pixels", "Failed to allocate memory");
	for(i = 0; i &lt; HEIGHT; i++)
		for(j = 0; j &lt; WIDTH; j++)
			pixels[i * WIDTH + j] = color1;
	return 1;
}

int
main(int argc, char** argv)
{
	int ticknext = 0;

	scn = Sc3d(0, 0, 0);
	cam = Cm3d(120, 20, 0);

	if(!init())
		return error("Init", "Failure");

	addfrustum(&amp;scn, 0, 0, 0, 12, 8, 10, 0.5);
	addprism(&amp;scn, 0, 0, 0, 12, 8, 10);
	scn.meshes[1].color = 1;

	clear();
	render(&amp;scn, &amp;cam);

	while(1) {
		int tick = SDL_GetTicks();
		SDL_Event event;
		if(event.type == SDL_QUIT)
			quit();
		if(tick &lt; ticknext)
			SDL_Delay(ticknext - tick);
		ticknext = tick + (1000 / FPS);
		while(SDL_PollEvent(&amp;event) != 0) {
			if(event.type == SDL_KEYDOWN)
				dokey(&amp;event);
		}
	}
	quit();
	return 0;
}
</pre><figcaption><a href='../archive/src/moogle.c.txt'>moogle.c</a> 678 lines</figcaption>
</figure><p>Moogle was first written on <a href='plan9.html'>Plan9</a>, the original <a href='plan9_c.html'>Plan9 C</a> implementation is available <a href='../archive/src/moogle9.c.txt' target='_blank'>here</a>.</p><figure><img src='../media/diary/728.jpg' alt='Moogle Spheroid picture' width='900'/><figcaption>20P01 — Moogle Spheroid</figcaption></figure><p><i>incoming(5)</i>: <a href='neauismetica.html'>neauismetica</a> <a href='graf3dscene.html'>graf3dscene</a> <a href='nasu.html'>nasu</a> <a href='defunct.html'>defunct</a> <a href='identity.html'>identity</a> </p><p><i>Last update on <a href='tracker.html'>20T04</a>, edited 5 times. +29/36fh</i><code style='float:right; font-size:80%'>-----+</code></p></main><footer><a href='https://creativecommons.org/licenses/by-nc-sa/4.0'><img src='../media/icon/cc.svg' width='30'/></a><a href='http://webring.xxiivv.com/'><img src='../media/icon/rotonde.svg' width='30'/></a><a href='https://merveilles.town/@neauoire'><img src='../media/icon/merveilles.svg' width='30'/></a><a href='https://github.com/neauoire'><img src='../media/icon/github.png' alt='github' width='30'/></a><span><a href='devine_lu_linvega.html'>Devine Lu Linvega</a> © 2020 — <a href='about.html'>BY-NC-SA 4.0</a></span></footer></body></html>