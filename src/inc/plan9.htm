<h3>Rio</h3>

<p>Rio is the name of the windowing system. To draw a new window on the screen you can right-click on an empty spot on the desktop and choose "New." You will see that the mouse cursor changes to a plus. Moving windows around doesn't work like with other systems. Since there's no window title bar at the top, you can't left-click and drag it around. Instead, you can right-click and drag using the border of the window. The mouse cursor turns into a box shape in the process. Alternatively, there is a Move option when you right-click on the desktop that allows you to right-click and drag anywhere on a window to move it around.</p>

<h3>Screencapture</h3>

<p>Sometimes it can be useful to record what's on your screen. For example, you can use screen shots for documentation. Also, providing a view of an error can help others to diagnose the problem. You can take a shot of the whole screen quite easily in a raw image format like this.</p>

<table border='1'>
  <tr><th>cat /dev/screen | topng &gt; screen.png</th><td>To capture the entire screen</td></tr>
  <tr><th>cat /dev/window | topng &gt; window.png</th><td>To capture only the current window</td></tr>
</table>

<h3>Acme</h3>

<p>Middle clicking on a word or some selected text *executes* that command. Right-clicking on a file can potentially open up a new window, depending on which program is registered to handle the file type. You can close windows by right-clicking on an empty spot on the desktop, choose Delete and then right click on the window.</p>

<table border='1'>
  <tr><th>Newcol</th><td>create a new column of windows</td></tr>
  <tr><th>Delcol</th><td>delete a column</td></tr>
  <tr><th>New</th><td>create a new window (edit it’s tag to be a file name and you would be creating a new file; you would need to click on “Put” to put the file in the file system).</td></tr>
  <tr><th>Put</th><td>write the body to disk. The file is the one named in the tag.</td></tr>
  <tr><th>Get</th><td>refresh the body (e.g. if it’s a directory, reread it and show it).</td></tr>
  <tr><th>Snarf</th><td>What other window systems call “Copy”.</td></tr>
  <tr><th>Paste</th><td>Can you guess it?</td></tr>
  <tr><th>Exit</th><td>exit acme</td></tr>
</table>

<h3>Simple Plan 9 C Example</h3>

<pre>
#include &lt;u.h&gt;
#include &lt;libc.h&gt;

void
main()
{
  print("hello, world\n");
  exits(0);
}
</pre>

<h3>Compilers</h3>

<p>To convert source to an executable binary is a two-step process. First run the compiler, <code>5c</code>, on the source, say <code>file.c</code>, to generate an object file <code>file.5</code>. Then run the loader, <code>5l</code>, to generate an executable <code>5.out</code> that may be run(on an ARM machine):</p>

<pre>
2c file.c
2l file.2 # Or, 2l file file.2
2.out
</pre>

<p>The loader automatically links with whatever libraries the program needs, usually including the standard C library as defined by <code>libc.h</code>. The compiler does not generate an executable automatically; the output of the compiler must be given to the loader. Since most compilation is done under the control of mk, this is rarely an inconvenience.</p>

<table border='1'>
  <tr><td>SPARC</td><td>kc</td><td>kl</td><td>ka</td></tr>
  <tr><td>PowerPC</td><td>qc</td><td>ql</td><td>qa</td></tr>
  <tr><td>MIPS</td><td>vc</td><td>vl</td><td>va</td></tr>
  <tr><td>ARM</td><td>5c</td>td><td>5l</td><td>5a</td></tr>
  <tr><td>AMD64</td><td>6c</td>td><td>6l</td><td>6a</td></tr>
  <tr><td>Intel</td><td>386</td>td><td>8c</td><td>8l</td></tr>
  <tr><td>PowerPC64bits</td><td>64</td><td>9c</td><td>9l</td></tr>
</table>

<h3>Themeing</h3>

<pre>hget http://plan9.stanleylieber.com/src/rio.mono.tgz > $home/rio.mono.tgz
tar zxf rio.mono.tgz
cd rio.mono
mk install</pre>

<p>To add this version of rio to open on launch.</p>

<pre>$home/lib/profile</pre>

<q>An argument for simplicity and clarity.</q>
<h5>—Rob Pike</h5>

<h2>Raspberry Pi</h2>

<p>Richard Miller distributes a pre-installed disk image for the <a href='https://www.raspberrypi.org/forums/viewtopic.php?f=80&t=210855&sid=d8c8f13ac97ccadf119e38781f495776' target='_blank'>raspberry pi with wifi support</a>. To compile applications for the Raspberry Pi, use the ARM compiler/linker <code>2c</code> and <code>2l</code>. To access the content of a USB stick, type <code>usbfat:</code>, and cd to the directory displayed.</p>

<h3>Networking</h3>

<pre>
ndb/dns # start the dns resolver
ip/ipconfig # configure interfaces and get ip address with dhcp
ip/ping google.com # check internet connection
</pre>

<pre>
webfs # start a filesystem that handle urls
abaco 'http://google.com/search?q=plan9'
</pre>