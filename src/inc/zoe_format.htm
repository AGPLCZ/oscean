<p>The content of the file contains only a series of octets representing pixels, it does does not feature any details about the picture size, every sequence of 4 pixels, is compressed into its hexadecimal value and the picture size is always expected to be a square. When the length of the zoe data is not a square, it is rounded up and read as a truncated square based on its length, so a 30 bytes file will be expanded to 16x16(32 bytes). </p>

<p>The following 4x4 picture data is compressed as <code>A3C5</code>.</p>

<table border='1'>
  <tr><td class='wb'>1</td><td class='bw'>0</td><td class='wb'>1</td><td class='bw'>0</td></tr>
  <tr><td class='bw'>0</td><td class='bw'>0</td><td class='wb'>1</td><td class='wb'>1</td></tr>
  <tr><td class='wb'>1</td><td class='wb'>1</td><td class='bw'>0</td><td class='bw'>0</td></tr>
  <tr><td class='bw'>0</td><td class='wb'>1</td><td class='bw'>0</td><td class='wb'>1</td></tr>
</table>

<p>The 16 pixels are represented as <code>A3C5</code>.</p>

<table border='1'>
  <tr><td colspan='4'>A</td><td colspan='4'>3</td><td colspan='4'>C</td><td colspan='4'>5</td></tr>
  <tr><td class='wb'>1</td><td class='bw'>0</td><td class='wb'>1</td><td class='bw'>0</td><td class='bw'>0</td><td class='bw'>0</td><td class='wb'>1</td><td class='wb'>1</td><td class='wb'>1</td><td class='wb'>1</td><td class='bw'>0</td><td class='bw'>0</td><td class='bw'>0</td><td class='wb'>1</td><td class='bw'>0</td><td class='wb'>1</td></tr>
</table>

<style>
  .bw { width:20px; height:20px; color:black; background:white }
  .wb { width:20px; height:20px; color:white; background:black }
</style>

<p>A 16x16 picture is expected to be 32 bytes, a 32x32 picture is expected to be 128 bytes in size, a 512x512 picture is expected to be about 32kb(32768 bytes) in size, and so on. </p>

<table border='1'>
  <tr><th>.gif</th><th>.zoe</th></tr>
  <tr>
    <td><img src='../media/generic/zoe.example.gif'/></td>
    <td><pre>
ffff ffff 807f ffff 807f ffff 807f ffff
807f ffff 807f 807f 887e 001f 887c 000f
8878 0007 8078 3f07 8070 7f83 8070 ffc3
8070 e1c3 8070 e1c3 8070 01c3 8070 03c3
8070 0783 8070 0f03 8070 1e03 8070 1c03
87f0 1c03 81f0 0003 81f0 1c07 81f0 1c07
81f0 1c0f 81e0 001f 8f80 007f 81ff ffff
81ff ffff 81ff ffff 81ff ffff ffff ffff
</pre></td>
  </tr>
</table>

<h3>Javascript Implementation</h3>

<p>The implementation used in <a href='noodle.htm'>Noodle</a>.</p>

<pre>
this.pack = (ctx,w,h) => {
  const byteArray = new Uint8Array(w*h / 8)
  const data = ctx.getImageData(0, 0, w, h).data
  const vals = [128, 64, 32, 16, 8, 4, 2, 1]
  for (var i = 0, n = data.length; i < n; i += 4) {
    const key = Math.floor(i / 32)
    const val = vals[(i / 4) % 8]
    const rgb = [data[i], data[i + 1], data[i + 2]]
    byteArray[key] += val * (lum(rgb) < 127 ? 1 : 0)
  }
  return byteArray
}

// Returns the luminance of a color.

function lum (pixel) {
  return Math.floor(0.2126 * pixel[0] + 0.7152 * pixel[1] + 0.0722 * pixel[2])
}
</pre>

<h3>Pascal Implementation</h3>

<p>TODO</p>

<h3>Ansi C Implementation</h3>

<p>TODO</p>