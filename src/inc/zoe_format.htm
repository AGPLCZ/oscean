<p>The content of the file contains only a series of bits representing pixels, it does does include any extra information about the picture, every sequence of 4 pixels, is encoded into its hexadecimal value and the picture size is always expected to be a square. When the length of the zoe data is not a square, it is rounded up and read as a truncated square based on its length, so a 30 bytes file will be expanded to 16x16(32 bytes). </p>

<p>The following 4x4 picture data is encoded as <code>a3c5</code>.</p>

<table border='1'>
  <tr><td class='wb'>1</td><td class='bw'>0</td><td class='wb'>1</td><td class='bw'>0</td></tr>
  <tr><td class='bw'>0</td><td class='bw'>0</td><td class='wb'>1</td><td class='wb'>1</td></tr>
  <tr><td class='wb'>1</td><td class='wb'>1</td><td class='bw'>0</td><td class='bw'>0</td></tr>
  <tr><td class='bw'>0</td><td class='wb'>1</td><td class='bw'>0</td><td class='wb'>1</td></tr>
</table>

<p>The series of 16 pixels are represented linearly as follows:</p>

<table border='1'>
  <tr><td colspan='4'>A</td><td colspan='4'>3</td><td colspan='4'>C</td><td colspan='4'>5</td></tr>
  <tr><td class='wb'>1</td><td class='bw'>0</td><td class='wb'>1</td><td class='bw'>0</td><td class='bw'>0</td><td class='bw'>0</td><td class='wb'>1</td><td class='wb'>1</td><td class='wb'>1</td><td class='wb'>1</td><td class='bw'>0</td><td class='bw'>0</td><td class='bw'>0</td><td class='wb'>1</td><td class='bw'>0</td><td class='wb'>1</td></tr>
</table>

<style>
  .bw { width:20px; height:20px; color:black; background:white }
  .wb { width:20px; height:20px; color:white; background:black }
</style>

<p>A 16x16 picture is expected to be 32 bytes, a 32x32 picture is expected to be 128 bytes in size, a 512x512 picture is expected to be about 32kb(32768 bytes) in size, and so on. </p>

<table border='1'>
  <tr><th>.gif</th><th>.zoe</th></tr>
  <tr>
    <td><img src='../media/generic/zoe.example1.gif'/></td>
    <td><pre>
ffff ffff 807f ffff 807f ffff 807f ffff
807f ffff 807f 807f 887e 001f 887c 000f
8878 0007 8078 3f07 8070 7f83 8070 ffc3
8070 e1c3 8070 e1c3 8070 01c3 8070 03c3
8070 0783 8070 0f03 8070 1e03 8070 1c03
87f0 1c03 81f0 0003 81f0 1c07 81f0 1c07
81f0 1c0f 81e0 001f 8f80 007f 81ff ffff
81ff ffff 81ff ffff 81ff ffff ffff ffff
</pre></td>
  </tr>
  <tr>
    <td><img src='../media/generic/zoe.example2.gif'/></td>
    <td><pre>
0c3f ffff 1440 0002 2480 0004 4500 0008
87ff fff0 8e00 0028 9fff ffc4 a000 0082
c000 0101 ffff fe02 8000 0304 8000 028c
8000 0254 8929 2224 8aaa a204 8aaa a204
8929 2204 8000 0204 8000 0204 8a4a 4204
8aaa a204 8aaa a204 8a4a 4204 8000 0204
8000 0204 8491 2208 8aaa a210 8aaa a220
8491 2240 8000 0280 8000 0300 ffff fe00
</pre></td>
  </tr>

</table>

<h3>Javascript Implementation</h3>

<p>The implementation used in <a href='noodle.html'>Noodle</a>.</p>

<pre>
// Convert context to

function zoeRead (ctx, w, h, x, y) {
  const size = w > h ? w : h
  const byteArray = new Uint8Array((size * size) / 8)
  const data = ctx.getImageData(x || 0, y || 0, w, h).data
  const vals = [128, 64, 32, 16, 8, 4, 2, 1]
  for (var i = 0, n = data.length; i < n; i += 4) {
    const key = Math.floor(i / 32)
    const val = vals[(i / 4) % 8]
    const rgb = [data[i], data[i + 1], data[i + 2]]
    byteArray[key] += val * (lum(rgb) < 127 ? 1 : 0)
  }
  return byteArray
}

function zoeWrite (ctx, byteArray) {
  const size = Math.floor(Math.sqrt(byteArray.length * 8))
  const vals = [128, 64, 32, 16, 8, 4, 2, 1]
  for (var y = 0; y < size; y++) {
    for (var x = 0; x < size; x++) {
      const key = x + (y * size)
      const byte = byteArray[Math.floor(key / 8)]
      const mask = vals[key % 8]
      ctx.fillStyle = (byte & mask) !== 0 ? 'black' : 'white'
      ctx.fillRect(x, y, 1, 1)
    }
  }
}

// Find the luminance of a color.

function lum (pixel) {
  return Math.floor(0.2126 * pixel[0] + 0.7152 * pixel[1] + 0.0722 * pixel[2])
}
</pre>

<h3>Pascal Implementation</h3>

<p>TODO</p>

<h3>Ansi C Implementation</h3>

<p>TODO</p>