<h3>Plan 9 C Example</h3>

<pre>
#include &lt;u.h&gt;
#include &lt;libc.h&gt;

void
main()
{
  print("hello, world\n");
  exits(0);
}
</pre>

<h3>Compilers</h3>

<p>To convert source to an executable binary is a two-step process. First run the compiler, <code>5c</code>, on the source, say <code>file.c</code>, to generate an object file <code>file.5</code>. Then run the loader, <code>5l</code>, to generate an executable <code>5.out</code> that may be run(on an ARM machine):</p>

<pre>
2c file.c
2l file.2 # Or, 2l file file.2
2.out
</pre>

<p>The loader automatically links with whatever libraries the program needs, usually including the standard C library as defined by <code>libc.h</code>. The compiler does not generate an executable automatically; the output of the compiler must be given to the loader. Since most compilation is done under the control of mk, this is rarely an inconvenience.</p>

<table border='1'>
  <tr><td></td><td>compiler</td><td>linker</td><td></td></tr>
  <tr><td>SPARC</td><td>kc</td><td>kl</td><td>ka</td></tr>
  <tr><td>PowerPC</td><td>qc</td><td>ql</td><td>qa</td></tr>
  <tr><td>MIPS</td><td>vc</td><td>vl</td><td>va</td></tr>
  <tr><td>ARM</td><td>5c</td><td>5l</td><td>5a</td></tr>
  <tr><td>AMD64</td><td>6c</td><td>6l</td><td>6a</td></tr>
  <tr><td>Intel386</td><td>8c</td><td>8l</td><td>8a</td></tr>
  <tr><td>PowerPC64bits</td><td>9c</td><td>9l</td><td>9a</td></tr>
</table>

<h3>Plan 9 GUI Example</h3>

<pre>
#include &lt;u.h&gt;
#include &lt;libc.h&gt;
#include &lt;draw.h&gt;
#include &lt;thread.h&gt;
#include &lt;event.h&gt;

void
eresized(int new)
{
  Rectangle r;
  r = screen->r;
  if(new && getwindow(display, Refnone) < 0)
    fprint(2,"can't reattach to window");
  draw(screen, screen->r, display->white, nil, ZP);
}

void
main(int argc, char **argv)
{
  Mouse m;
  Image *red, *blue;
  initdraw(0,0,0);
  eresized(0);
  einit(Emouse);
  red = allocimagemix(display, DRed, DRed);
  blue = allocimagemix(display, DBlue, DBlue);
  for(;;){
    m = emouse();
    if(m.buttons & 4)
      break;
    if(m.buttons & 1){
      fillellipse(screen, m.xy, 5, 5, red, ZP);
      do m=emouse(); while(m.buttons & 1);
      fillellipse(screen, m.xy, 5, 5, blue, ZP);
      continue;
    }
    draw(screen, rectaddpt(Rect(0,0,2,2), m.xy), display->black, nil, ZP);
  }
}
</pre>

<h3>Plan 9 GUI Menu Example</h3>

<pre>
#include &lt;u.h&gt;
#include &lt;libc.h&gt;
#include &lt;draw.h&gt;
#include &lt;thread.h&gt;
#include &lt;event.h&gt;

char *buttons[] = {"Option1", "Option2", "Option3", "Exit", 0};
Menu menu = {buttons};
Point p;

void
eresized(int new)
{
  Rectangle r;
  r = screen->r;
  if(new && getwindow(display, Refnone) < 0)
    fprint(2,"can't reattach to window");
  draw(screen, screen->r, display->white, nil, ZP);
}

void 
main(int argc, char *argv[]) 
{
  USED(argc, argv);
  Event ev;
  int e, timer;
  if (initdraw(nil, nil, "bouncing ball demo") < 0)
    sysfatal("initdraw failed: %r");
  einit(Emouse);
  eresized(0);
  for (;;) {
    e = event(&ev);
    if ((e == Emouse) && (ev.mouse.buttons & 4)){
      if(emenuhit(3, &ev.mouse, &menu) == 0)
        print("Pressed Option 1");
      if(emenuhit(3, &ev.mouse, &menu) == 1)
        print("Pressed Option 2");
      if(emenuhit(3, &ev.mouse, &menu) == 2)
        print("Pressed Option 3");
      if(emenuhit(3, &ev.mouse, &menu) == 3)
        exits(nil);
    }
  }
}
</pre>

<h3>Bresenham Line Algorithm</h3>

<pre>
void
pixel(int x, int y)
{
  Point from, to;
  Rectangle r;

  r.min.x = x;
  r.min.y = y;
  r.max.x = x + 1;
  r.max.y = y + 1;
  draw(screen, r, display->black, nil, ZP);
}

void lineb(int x0, int y0, int x1, int y1)
{
  int dx = abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
  int dy = -abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
  int err = dx + dy, e2;
  for(;;){
    pixel(x0,y0);
    if(x0 == x1 && y0 == y1) break;
    e2 = 2 * err;
    if(e2 >= dy) { err += dy; x0 += sx; }
    if(e2 <= dx) { err += dx; y0 += sy; }
  }
}

/* Usage */

lineb(screen->r.min.x, screen->r.min.y, screen->r.max.x, screen->r.max.y);
</pre>