<p>The Runtime.lib library contains all standard Pascal routines such as <code>writeln</code> and <code>sqrt</code>. The Interface.lib library contains the "glue code" for all Macintosh Toolbox. Since routines from these two libraries are commonly used in almost all Pascal programs on the Macintosh, they are automatically included in the project file.</p>

<pre>
program Hello;

  {Comment}

 var
  name: string;

begin

 name := 'alice';
 if (name = 'alice') then
  writeln('The name is alice.')
 else if (a = 'bob') then
  writeln('The name is bob.')
 else
  writeln('The name is not alice nor bob.');

end.
</pre>

<h3>Creating a procedure</h3>

<pre>A procedure definition in Pascal consists of a header, local declarations and a body of the procedure. The procedure header consists of the keyword procedure and a name given to the procedure. A procedure does not return anything.</pre>

<pre>
program ExampleProcedure;

 procedure Tri (x, y, side: integer);
 begin
  MoveTo(x, y);
  LineTo(x + side, y);
  LineTo(x + side div 2, Round(y + Side / Sqrt(2)));
  LineTo(x, y);
 end;

begin
 Tri(10, 10, 100);
 Tri(40, 40, 80);
 Tri(80, 85, 180);
end.
</pre>

<h3>Creating a function</h3>

<p>A function declaration tells the compiler about a function's name, return type, and parameters. A function definition provides the actual body of the function.</p>

<pre>
program ExampleFunction;

 function add (a, b: integer): integer;
 begin
  add := a + b;
 end;

begin
 writeln('5+6=', add(5, 6));
end.
</pre>

<h3>Creating a type</h3>

<p>An Object is a special kind of record that contains fields like a record; however, unlike records, objects contain procedures and functions as part of the object. These procedures and functions are held as pointers to the methods associated with the object's type.</p>

<pre>
program Example;

 type
  Rectangle = object
    width, height: integer;
   end;
 var
  r1: Rectangle;

begin

 new(r1);
 r1.width := 12;
 r1.height := 34;
 writeln('The rect is ', r1.width, 'x', r1.height);

end.
</pre>

<h3>Creating a type with a method</h3>

<pre>
program Example;

 type
  Rectangle = object
    width, height: integer;
    procedure setwidth (w: integer);
   end;

 var
  r1: Rectangle;

 procedure Rectangle.setwidth (w: integer);
 begin
  width := w;
 end;

begin

 new(r1);
 r1.width := 12;
 r1.height := 34;
 writeln('The rect was ', r1.width, ' x ', r1.height);
 r1.setWidth(56);
 writeln('The rect is now ', r1.width, ' x ', r1.height);

end.
</pre>

<p>Think Pascal is a development system for the Macintosh, released by Think Technologies in 1986 as Lightspeed Pascal. Think Technologies was bought by Symantec, and the name was changed to Think Pascal. The last official update came 1992, and the product was officially discontinued in 1997.</p>

<h3>Console Program</h3>

<pre>
program Greetings;

 const
  message = ' Welcome to the world of Pascal ';

 type
  name = string;

 var
  firstname, surname: name;

begin

 writeln('Please enter your first name: ');
 readln(firstname);

 writeln('Please enter your surname: ');
 readln(surname);

 writeln;
 writeln(message, ' ', firstname, ' ', surname);

end.
</pre>

<h3>GUI Program</h3>

<pre>
program Test;

 var
  w: WindowPtr; {A window to draw in}
  r: Rect; {The bounding box of the window}

begin

  {Create the window}
 SetRect(r, 50, 50, 200, 100);
 w := NewWindow(nil, r, '', true, plainDBox, WindowPtr(-1), false, 0);

  {Make it the current drawing port}
 SetPort(w);

  {Draw a string!}
 MoveTo(5, 20);
 DrawString('Hello world!');

  {Wait for a mouse-click, then stop.}
 while not Button do
  ;

end.
</pre>

<h3>Graphics Primitives</h3>

<p>Graphical user interface design rests firmly on the foundation of OOP and illustrates its power and elegance. </p>

<table border='1'>
  <tr>
    <td width="51">Object</td>
    <td width="150">Pascal</td>
    <td width="127">Example</td>
    <td width="147">Description</td>
  </tr>
  <tr>
    <td width="51">Pen</td>
    <td width="150">Procedure PenSize( width, height:INTEGER)</td>
    <td width="107">PenSize(2,2);</td>
    <td width="147">Sets the size of the plotting pen, in pixels</td>
  </tr>
  <tr>
    <td width="51">Pen- move absolute</td>
    <td width="150">Procedure MoveTo(h,v: INTEGER)</td>
    <td width="107">MoveTo(100,50);</td>
    <td width="147">Moves pen (invisibly) to pixel (h,v) (absolute coordinates)</td>
  </tr>
  <tr>
    <td width="51">Pen- move relative</td>
    <td width="150">Procedure Move(dh,dv: INTEGER)</td>
    <td width="107">Move(10,10);</td>
    <td width="147">Moves pen (invisibly) dh pixels horizontally and dv pixels vertically (relative coordinates)</td>
  </tr>
  <tr>
    <td width="51">Point</td>
    <td width="150">Procedure DrawLine(x1,y1, x1,y1:INTEGER)</td>
    <td width="107">DrawLine(50,100,50,100)</td>
    <td width="147">Draws a line from point (x1,y1) to the second point, (x1,y1), i.e. a point</td>
  </tr>
  <tr>
    <td width="51">Point</td>
    <td width="150">Procedure MoveTo(x1,y1: INTEGER) <p>Procedure LineTo(x1,y1: INTEGER)</p></td>
    <td width="107">MoveTo(50,100) <p>LineTo(50,100)</p></td>
    <td width="147">Moves to pixel (x1,y1) and draws a line to (x1,y1), i.e. a point</td>
  </tr>
  <tr>
    <td width="51">Point</td>
    <td width="150">Procedure Line(dx,dy: INTEGER)</td>
    <td width="107">Line(0,0);</td>
    <td width="147">From the present position of the pen, draw a line a distance (0,0)</td>
  </tr>
  <tr>
    <td width="51">Line - absolute</td>
    <td width="150">Procedure DrawLine(x1,y1, x2,y2:INTEGER)</td>
    <td width="107">DrawLine(50,100,200,300)</td>
    <td width="147">Draws a line from point (x1,y1) to the second point, (x2,y2)</td>
  </tr>
  <tr>
      <td width="51">Line - absolute</td>
      <td width="150">Procedure MoveTo(x1,y1: INTEGER) <p>Procedure LineTo(x2,y2: INTEGER)</p></td>
      <td width="107">MoveTo(50,100) <p>LineTo(200,300)</p></td>
      <td width="147">Moves to pixel (x1,y1) and draws a line to (x2,y2)</td>
  </tr>
  <tr>
      <td width="51">Line - relative</td>
      <td width="150">Procedure Line(dx,dy: INTEGER)</td>
      <td width="107">Line(100,200);</td>
      <td width="147">Draw a line a distance (dx,dy) relative to the present pen position</td>
  </tr>
  <tr>
      <td width="51">Text</td>
      <td width="150">Procedure WriteDraw(p1 [,p2Ö, pn])</td>
      <td width="107">WriteDraw(ÎPen at:',x,y)</td>
      <td width="147">The WriteLn equivalent procedure for the drawing window</td>
  </tr>
  <tr>
      <td width="51">Drawing Window</td>
      <td width="150">Procedure ShowDrawing</td>
      <td width="107">ShowDrawing;</td>
      <td width="147">Opens the Drawing Window</td>
  </tr>
</table>

<h3>Graphic Primitives Example</h3>

<pre>
program Primitives;

  {Program to demonstrate Pascal point & line primitives.}

begin

 ShowDrawing; {Opens Drawing Window}

  {First draw three points by three different functions}

 PenSize(1, 1); {Sets pen size to 1 x 1 pixels}
 DrawLine(50, 50, 50, 50);
 WriteDraw(' Point at (50,50) using DrawLine');

 PenSize(2, 2);
 MoveTo(100, 75); {Absolute move}
 LineTo(100, 75);
 WriteDraw(' Point at (100,75) using LineTo');

 PenSize(3, 3);
 MoveTo(150, 100); {Absolute move}
 Line(0, 0);
 WriteDraw(' Point at (150,100) using Line');

  {Now Draw three lines by three different functions}

 MoveTo(150, 175); {Absolute move}
 WriteDraw('Line drawn with DrawLine');
 DrawLine(150, 125, 50, 225);

 PenSize(2, 2);
 Move(0, 25); {Relative move}
 LineTo(150, 250);
 WriteDraw('Line drawn by LineTo');

 Pensize(1, 1);
 Move(0, 25); {Relative move}
 Line(-100, 50);
 WriteDraw('Line drawn by Line');

end.
</pre>

<h3>Graphics Primitives - Geometric Figures</h3>

<table border='1'>
    <tr>
      <td width="48"></td>
      <td width="90">Rectangles<br />(Squares)</td>
      <td width="90">Ovals<br />(Circles)</td>
      <td width="106">Rounded-Corner<br />Rectangles</td>
      <td width="97">Arcs and<br />Wedges</td>
    </tr>
    <tr>
      <td width="48">Frame</td>
      <td width="81">Procedure<br />FrameRect(r:Rect)</td>
      <td width="81">Procedure<br />FrameOval(r:Rect)</td>
      <td width="106">Procedure Frame Round Rect (r:Rect; ovalWidth, ovalHeight:Integer)</td>
      <td width="97">Procedure FrameArc (r:Rect;startAngle, arcAngle:Integer)</td>
    </tr>
    <tr>
      <td width="48">Paint</td>
      <td width="81">Procedure<br/>PaintRect(r:Rect)</td>
      <td width="81">Procedure<br/>PaintOval(r:Rect)</td>
      <td width="106">Procedure Paint Round Rect(r:Rect; ovalWidth, ovalHeight:Integer)</td>
      <td width="97">Procedure PaintArc (r:Rect;startAngle, arcAngle:Integer)</td>
    </tr>
    <tr>
      <td width="48">Erase</td>
      <td width="81">Procedure<br/>EraseRect(r:Rect)</td>
      <td width="81">Procedure<br/>EraseOval(r:Rect)</td>
      <td width="106">Procedure Erase Round Rect(r:Rect; oval Width, ovalHeight:Integer)</td>
      <td width="97">Procedure EraseArc (r:Rect;startAngle, arcAngle:Integer)</td>
    </tr>
    <tr>
      <td width="48">Invert</td>
      <td width="81">Procedure<br/>InvertRect(r:Rect)</td>
      <td width="81">Procedure<br/>InvertOval(r:Rect)</td>
      <td width="106">Procedure Invert Round Rect(r:Rect; ovalWidth, ovalHeight:Integer)</td>
      <td width="97">Procedure InvertArc (r:Rect;startAngle, arcAngle:Integer)</td>
    </tr>
    <tr>
      <td width="48">Fill</td>
      <td width="81">Procedure<br/>FillRect(r:Rect, pat:Pattern)</td>
      <td width="81">Procedure<br/>FillOval(r:Rect,pat:Pattern)</td>
      <td width="106">Procedure FillRound Rect(r:Rect; ovalWidth, ovalHeight:Integer, pat:Pattern)</td>
      <td width="97">Procedure FillArc (r:Rect;startAngle, arcAngle:Integer, pat:Pattern)</td>
    </tr>
</table>

<h3>Spiral Pattern</h3>

<pre>
program Pattern;

  {Program to build spiral pattern, using}
  {relative line routine in a recursive loop}

 var
  sign: integer;

 procedure Spiral (x, y, sign: integer);

  {Procedure to spiral into limbo}

  var
   temp: integer;

 begin

  sign := (-1) * sign;
  if (abs(x) < 10) and (abs(y) < 10) then
   halt {Done recurring - ground case}
  else {Spiral still sizable}
   begin

    line(x, y); {Plot relative line}

  {Reduce magnitude of relative move by 5 pixels}

    if abs(x) > abs(y) then
     x := x - (x div abs(x) * 5)
    else
     y := y - (y div abs(y) * 5);

  {Exchange x<--> y}

    temp := x;
    x := y;
    y := temp;

  {On even calls, change sign}

    x := sign * x;
    y := sign * y;
    Spiral(x, y, sign); {Recur}
   end;

 end;

begin

 sign := 1;
 PenSize(9, 9);
 ShowDrawing;
 MoveTo(20, 20);
 Spiral(200, 0, -1);

end.
</pre>

<h3>Button Events</h3>

<table border='1'>
    <tr>
        <td width="48">Object</td>
        <td width="116">Pascal Syntax</td>
        <td width="104">Example Call</td>
        <td width="166">Description</td>
    </tr>

    <tr>
        <td width="48">
            Button
        </td>

        <td width="106">Function Button:Boolean</td>

        <td width="94">if Button then <font face="Symbol">º<br/>

            <p>else<font face="Symbol">º
            </p>
        </td>

        <td width="166">The Button function returns <i>True</i> if
the mouse button is down; <i>False</i> otherwise</td>
    </tr>

    <tr>
        <td width="48">
            Button
        </td>

        <td width="106">Function StillDown: Boolean</td>

        <td width="94">if StillDown then<font face="Symbol">º<br/>

            <p>else<font face="Symbol">º
            </p>
        </td>

        <td width="166">Returns <i>True</i> if the button is still
down from the original press; <i>False</i> if it has been released or released
and repressed (i.e., mouse event on event queue)</td>
    </tr>

    <tr>
        <td width="48">
            Button
        </td>

        <td width="106">Function WaitMouseUp:Boolean</td>

        <td width="94">if WaitMouseUp then<font face="Symbol">º<br/>

            <p>else<font face="Symbol">º
            </p>
        </td>

        <td width="166">Same as StillDown, but removes previous mouse
event from queue before returning False</td>
    </tr>

    <tr>
        <td width="48">
            Mouse cursor
        </td>

        <td width="106">Procedure GetMouse(<b>var</b> mouseLoc:point)</td>

        <td width="94">GetMouse(p);</td>

        <td width="166">Returns the present mouse cursor position
in local coordinates as a Point type</td>
    </tr>

    <tr>
        <td width="48">
            Keyboard
        </td>

        <td width="106">Procedure GetKeys(<b>var</b> theKeys:KeyMap)</td>

        <td width="94">GetKeys(key);</td>

        <td width="166">Reads the current state of the keyboard and
returns a keyMap, a Packed Array[1..127] of Boolean</td>
    </tr>

    <tr>
        <td width="48">
            Clock
        </td>

        <td width="106">Function TickCount:LongInt</td>

        <td width="94">if TickCount&lt;60 then<font face="Symbol">º
        </td>

        <td width="166">Returns the elapsed time in ticks (1/60th
sec) since last TickCount call</td>
    </tr>

    <tr>
        <td width="48">
            Event
        </td>

        <td width="106">Function GetNextEvent<br/>

            <p>(eventMask:Integer;<b>var</b> theEvent:EventRecord): Boolean</p>
        </td>

        <td width="94">if GetNextEvent(2,Rec)<br/>

            <p>then<font face="Symbol">º<br/>

            </p>
            <p>else<font face="Symbol">º
            </p>
        </td>

        <td width="166">A logical function which returns <i>True</i>
if an event of the requested type exists on the event queue; <i>False</i>
otherwise. If <i>True</i>, it also returns a descriptive record of the
event. (type, location, time, conditions, etc)</td>
    </tr>
</table>

<h3>Drawing Program</h3>

<pre>
program RubberBand;

{Program to demonstrate Rubber Band technique}
{for constructing graphical objects }
 var
  x1, y1, x2, y2: integer;
  p: point;
begin

 ShowDrawing; {Open Drawing Window}
 MoveTo(20, 20); {Label graph and options}
 TextSize(18);
 WriteDraw('Rubber Band Program');
 TextSize(10);
 MoveTo(30, 40);
 WriteDraw('* Button down to draw line');
 MoveTo(30, 50);
 WriteDraw('* Double-click left of window to QUIT');
 PenMode(patXor); {Set Pen Mode to Xor}
    {to erase and redraw line}
 repeat {Keep working until exit}
  if Button then {executes once/line}
   begin
    GetMouse(p); {Read first point on line}
    x1 := p.h; {horizontal element of point}
    y1 := p.v;
{ vertical element of point }
    while Button do {Loop until button released}
     begin
      GetMouse(p); {Read second point}
      x2 := p.h; {horizontal element}
      y2 := p.v;
{ vertical element }
      DrawLine(x1, y1, x2, y2); {Draw line}
      DrawLine(x1, y1, x2, y2); {Erase line}
     end; {Now redraw permanent line }

    DrawLine(x1, y1, x2, y2);
   end;

 until (x1 < 0) and Button {Exit by clicking left}

end. {of Drawing Window}
</pre>

<h3>Notes</h3>

<p>A semi-colon is not required after the last statement of a block, adding one adds a "null statement" to the program, which is ignored by the compiler.</p>

<p>The programmer has the freedom to define other commonly used data types (e.g. byte, string, etc.) in terms of the predefined types using Pascal's type declaration facility, for example:</p>

<pre>
type
  byte        = 0..255;
  signed_byte = -128..127;
  string      = packed array[1..255] of char;
</pre>

<h3>Patterns</h3>

<p>The available patterns are:</p>

<ul>
  <li>black</li>
  <li>dkgray</li>
  <li>gray</li>
  <li>ltgray</li>
  <li>white</li>
</ul>

<p>The following Think Pascal commands will be useful to you in writing interactive graphics programs on the Macintosh.  They are listed by type:</p>
<p><b>Window Commands:</b><p>
These commands will manipulate the various windows in Think Pascal.<p>
<dl>
<dt><TT>ShowDrawing</TT> <dd>Open the drawing window (if not already open) and make it
the active window on the screen.  Should be used when first draw to drawing
window and anytime shift from text to drawing window.<p>
<dt><TT>ShowText</TT> <dd>Similarly for the text window.<p>
<dt><TT>HideAll</TT>  <dd>Closes all Think Pascal windows on the screen.<p>
</dl>
<b>Commands to move current point:</b><p>
The drawing window remembers where the  pen was last.  This place in
the window is known as the current point (CP).<p>
<dl>
<dt><TT>MoveTo(X_Coord, Y_Coord)</TT>  
            <dd>Sets CP to (X_Coord, Y_Coord)<p>
<dt><TT>Move(X_Diff, Y_Diff)</TT>
    <dd>Moves  CP  X_Diff to right and Y_Diff down.<p>
<dt><TT>LineTo(X_Coord, Y_Coord)</TT> <dd>Draws line from CP to  (X_Coord,
Y_Coord).     CP is moved to new position.<p>
<dt><TT>Line(X_Diff, Y_Diff)</TT>   <dd>Draws line from CP  X_Diff to right and
Y_Diff  down.  CP is moved to new position.<p>
<dt><TT>DrawLine(Start_X, Start_Y, End_X, End_Y)</TT>  <dd>Draws line from
(Start_X, Start_Y) to 
      (End_X, End_Y) leaving CP at  (End_X, End_Y).<p>
</dl>
<b>Commands to draw outlines of shapes:</b><p>
<dl>
<dt><TT>FrameRect(top, left, bottom, right)</TT>
    <dd>Draws outline of rectangle whose
highest point is at top, leftmost at  left, lowest at
bottom and rightmost at  right<p>
<dt><TT>FrameOval(top, left, bottom, right)</TT>
    <dd>Similar to above but draws an oval
inscribed in the rectangle.<p>
<dt><TT>FrameArc(top, left, bottom, right, start_angle, num_degrees)</TT>
    <dd>Draws that part of an oval ranging from  start_angle to
start_angle + num_degrees (0 degrees is at top).<p>
<dt><TT>FrameRoundRect(top, left, bottom, right, oval_width, oval_ht)</TT>
    <dd>Draws rectangle with rounded corners.  The corners are quarter 
  ovals determined by oval_width and oval_ht.<p>
</dl>
<b>More commands to draw shapes:</b><p>
<dl>
<dt><TT>PaintRect(top, left, bottom, right)</TT>
    <dd>  Draw outline of rectangle and
fill it with the current pen pattern.<p>
<dt><TT>EraseRect(top, left, bottom, right) </TT>
    <dd>Paints rectangle with the
background color (usually white).  The net effect is to erase the
rectangle.<p>
<dt><TT>InvertRect(top, left, bottom, right)</TT>
    <dd>  Reverse all pixels in the
rectangle (i.e. all formerly white dots are painted black and
vice-versa).<p>
</dl>
<I>Paint, Erase, and Invert can also be prefixed to Oval, Arc, and RoundRect
for similar effects.</I><p>

<b>Writing words on the screen:</b><p>
<dl>
<dt><TT>Writeln('text'')</TT>
    <dd>  Prints  text to the Text Window and
moves cursor to next line.<p>
<dt><TT>Writeln(integer)</TT>
    <dd>  Prints  integer in the Text Window and
moves cursor to next line.<p>
<dt><TT>Writeln(integer : d )</TT>
    <dd>  Prints  integer in the Text
Window using at least  d spaces and then moves cursor to next
line.<p>
<dt><TT>Write('text'')</TT>
    <dd>  Prints  text to the Text Window but does
not move cursor to next line.<p>
<dt><TT>WriteDraw('text'')</TT>
    <dd>  Prints  text to the Drawing Window,
starting at the CP.  The CP is left at the lower right corner of the last
character drawn.<p>
</dl>
<I>Note that Write and Writedraw can both be used to print integers similarly
to Writeln.</I><p>
<p>
<b>Command to change pattern of pen:</b><p>
<dl>
<dt><TT>PenPat(New_pat)</TT>
    <dd>  Changes pen pattern to  New_pat if
<I>New_pat is one of  black, white, dkGray, gray, ltGray.</I><p>
</dl>
<b>Command to change colors drawn on screen:</b><p>
<dl>
<dt><TT>ForeColor(new_color)</TT>
    <dd>  Changes color of any new objects drawn to
new_color where  new_color is one of  blackColor, whiteColor,
redColor, greenColor, blueColor, cyanColor, magentaColor, and
yellowColor.<p>
<dt><TT>BackColor(new_color)</TT>
    <dd>  Changes background color of all areas which will be
"erased" to  new_color.<p>
</dl>
<I>Notes:  In the three commands above the type of New_pat is a
built-in Mac type, Pattern.  The type of new_color is  longint.
It is only necessary to know their types if you need to pass them as
parameters to other procedures.</I><p>
<p>
<b>Graphics types:</b><p>
<dl>
<dt><TT>Rect, Point </TT>
    <dd> implemented as records - Rect has fields left, top, right,
bottom : integer, Point has fields h, v : integer<p>
</dl>
<b>Procedures to create and test points and rectangles:</b><p>
<dl>
<dt><TT>PROCEDURE SetPt(VAR pt : Point; h,v : INTEGER)</TT>
    <dd> Make point,  pt,with coords  (h,v)<p>
<dt><TT>PROCEDURE SetRect(VAR r : Rect; left, top, right, bottom : INTEGER)</TT>
    <dd>Make rectangle with coords  (left,top) and  (right,bottom)
as corners.<p>
<dt><TT>PROCEDURE Pt2Rect( pt1, pt2 : Point; dstRect : Rect);</TT>
    <dd>Make
rectangle with  pt1 and  pt2 as corners<p>
<dt><TT>PROCEDURE PtInRect(pt:Point; r : Rect) : BOOLEAN;</TT>
    <dd>Determine if  pt is in the rectangle  r.<p>
</dl>
<b>Sizing Windows:</b><p>
<dl>
<dt><TT>SetDrawingRect(WindowRect)</TT>
    <dd>  Set Drawing Window to fit
WindowRect<p>
<dt><TT>SetTextRect(WindowRect)</TT>
    <dd>    Set Text Window to fit  WindowRect<p>
</dl>