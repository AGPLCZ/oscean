<p>The Runtime.lib library contains all standard Pascal routines such as <code>writeln</code> and <code>sqrt</code>. The Interface.lib library contains the "glue code" for all Macintosh Toolbox. Since routines from these two libraries are commonly used in almost all Pascal programs on the Macintosh, they are automatically included in the project file.</p>

<p>Graphical user interface design rests firmly on the foundation of OOP and illustrates its power and elegance. Some of the most important OOP concepts are listed below.</p>

<ul>
    <li><b>Objects</b>: These are defined as data and the closely associated actions which operate on the data. This integration of data and operations into a single object is called encapsulation. In GUI design, objects are abstracted as icons and menus which represent folders, files, application programs, processes, and operations.</li>
    <li><b>Messages</b>: These are defined as the requests sent to an object to execute the actions of which it is capable. Different objects may support different messages and may respond identically or differently to the same message. In GUI design, messages may be sent by the mouse in performing actions such as selection, launching, copying, restructuring, trashing, and ejecting. Messages commanding actions of saving, duplicating, printing, cutting, copying, and pasting may be sent via either the mouse or keyboard. The same message may cause different actions in different icons -- a single click selects some icons and opens others.</li>
    <li><b>Methods</b>: These are the routines and algorithms for implementing messages. In GUI design, methods are implemented by high-level routines supported by the event manager, windows manager, menu manager, and so on.</li>
    <li><b>Class</b>: erarchy - Each object belongs to a class and is called an instance of the class. Class hierarchy provides for superclasses and subclasses. All objects of a subclass inherit the data and behavior defined by the superclass of which they are members. The class without a superclass is called the root class. A given class supports certain methods common to all members of the class. In GUI design, classes exist for data files, applications programs, menu headers, and menu selection items.</li>
    <li><b>Inheritance</b>: Membership in a class provides inheritance of data and methods for all members of the class. Members of a subclass inherit all the instance variables and methods of its superclass unless it chooses to override them with local variables and/or methods. Inheritance provides advantages of reducing data redundancy and action code duplication. In GUI design, all data icons share the method of examining their own creator slot and searching for the application program it points to when they are opened. However, the subclass of WINGZ data files differs significantly from the subclass of MS-Word data files in its icon style, creator designation, internal file structure and so on.</li>
    <li><b>Polymorphism</b>: Literally multiple forms, this feature of OOP means that the same message may be sent to objects of different classes. The response from members of distinct classes may be identical to, similar to, or completely distinct from each other, depending on the method chosen by each class for implementing the message. In GUI design, for instance, all members of the data file class may meekly vanish without trace when dragged to the trash can, whereas icons from the more important application program class will bravely challenge the user with the warning shown in Figure 3.10, and disk icons will interpret the same message as "eject yourself."</li>
</ul>

<h3>Graphics Primitives</h3>

<table border='1'>
  <tr>
    <td width="51">Object</td>
    <td width="150">Pascal</td>
    <td width="127">Example</td>
    <td width="147">Description</td>
  </tr>
  <tr>
    <td width="51">Pen</td>
    <td width="150">Procedure PenSize( width, height:INTEGER)</td>
    <td width="107">PenSize(2,2);</td>
    <td width="147">Sets the size of the plotting pen, in pixels</td>
  </tr>
  <tr>
    <td width="51">Pen- move absolute</td>
    <td width="150">Procedure MoveTo(h,v: INTEGER)</td>
    <td width="107">MoveTo(100,50);</td>
    <td width="147">Moves pen (invisibly) to pixel (h,v) (absolute coordinates)</td>
  </tr>
  <tr>
    <td width="51">Pen- move relative</td>
    <td width="150">Procedure Move(dh,dv: INTEGER)</td>
    <td width="107">Move(10,10);</td>
    <td width="147">Moves pen (invisibly) dh pixels horizontally and dv pixels vertically (relative coordinates)</td>
  </tr>
  <tr>
    <td width="51">Point</td>
    <td width="150">Procedure DrawLine(x1,y1, x1,y1:INTEGER)</td>
    <td width="107">DrawLine(50,100,50,100)</td>
    <td width="147">Draws a line from point (x1,y1) to the second point, (x1,y1), i.e. a point</td>
  </tr>
  <tr>
    <td width="51">Point</td>
    <td width="150">Procedure MoveTo(x1,y1: INTEGER) <p>Procedure LineTo(x1,y1: INTEGER)</p></td>
    <td width="107">MoveTo(50,100) <p>LineTo(50,100)</p></td>
    <td width="147">Moves to pixel (x1,y1) and draws a line to (x1,y1), i.e. a point</td>
  </tr>
  <tr>
    <td width="51">Point</td>
    <td width="150">Procedure Line(dx,dy: INTEGER)</td>
    <td width="107">Line(0,0);</td>
    <td width="147">From the present position of the pen, draw a line a distance (0,0)</td>
  </tr>
  <tr>
    <td width="51">Line - absolute</td>
    <td width="150">Procedure DrawLine(x1,y1, x2,y2:INTEGER)</td>
    <td width="107">DrawLine(50,100,200,300)</td>
    <td width="147">Draws a line from point (x1,y1) to the second point, (x2,y2)</td>
  </tr>
  <tr>
      <td width="51">Line - absolute</td>
      <td width="150">Procedure MoveTo(x1,y1: INTEGER) <p>Procedure LineTo(x2,y2: INTEGER)</p></td>
      <td width="107">MoveTo(50,100) <p>LineTo(200,300)</p></td>
      <td width="147">Moves to pixel (x1,y1) and draws a line to (x2,y2)</td>
  </tr>
  <tr>
      <td width="51">Line - relative</td>
      <td width="150">Procedure Line(dx,dy: INTEGER)</td>
      <td width="107">Line(100,200);</td>
      <td width="147">Draw a line a distance (dx,dy) relative to the present pen position</td>
  </tr>
  <tr>
      <td width="51">Text</td>
      <td width="150">Procedure WriteDraw(p1 [,p2Ö, pn])</td>
      <td width="107">WriteDraw(ÎPen at:',x,y)</td>
      <td width="147">The WriteLn equivalent procedure for the drawing window</td>
  </tr>
  <tr>
      <td width="51">Drawing Window</td>

      <td width="150">Procedure ShowDrawing</td>

      <td width="107">ShowDrawing;</td>

      <td width="147">Opens the Drawing Window</td>
  </tr>
</table>

<pre>
program Primitives;

  {Program to demonstrate Pascal point & line primitives.}

begin

 ShowDrawing; {Opens Drawing Window}

  {First draw three points by three different functions}

 PenSize(1, 1); {Sets pen size to 1 x 1 pixels}
 DrawLine(50, 50, 50, 50);
 WriteDraw(' Point at (50,50) using DrawLine');

 PenSize(2, 2);
 MoveTo(100, 75); {Absolute move}
 LineTo(100, 75);
 WriteDraw(' Point at (100,75) using LineTo');

 PenSize(3, 3);
 MoveTo(150, 100); {Absolute move}
 Line(0, 0);
 WriteDraw(' Point at (150,100) using Line');

  {Now Draw three lines by three different functions}

 MoveTo(150, 175); {Absolute move}
 WriteDraw('Line drawn with DrawLine');
 DrawLine(150, 125, 50, 225);

 PenSize(2, 2);
 Move(0, 25); {Relative move}
 LineTo(150, 250);
 WriteDraw('Line drawn by LineTo');

 Pensize(1, 1);
 Move(0, 25); {Relative move}
 Line(-100, 50);
 WriteDraw('Line drawn by Line');

end.
</pre>

<h3>Graphics Primitives - Geometric Figures</h3>

<table border='1'>

    <tr>
        <td width="48">
            <i>Object</i><font face="Symbol">Æ

            <font face="Symbol">Ø<i>Message</i>

        </td>

        <td width="90">
            Rectangles

            (Squares)
        </td>

        <td width="90">
            Ovals

            (Circles)
        </td>

        <td width="106">
            Rounded-Corner

            Rectangles
        </td>

        <td width="97">
            Arcs and

            Wedges
        </td>
    </tr>

    <tr>
        <td width="48">
            Frame
        </td>

        <td width="81">Procedure&nbsp

            <p>FrameRect(r:Rect)</p>
        </td>

        <td width="81">Procedure&nbsp

            <p>FrameOval(r:Rect)</p>
        </td>

        <td width="106">Procedure Frame Round Rect (r:Rect; ovalWidth, ovalHeight:Integer)</td>

        <td width="97">Procedure FrameArc (r:Rect;startAngle, arcAngle:Integer)</td>
    </tr>

    <tr>
        <td width="48">
            Paint
        </td>

        <td width="81">Procedure&nbsp

            <p>PaintRect(r:Rect)</p>
        </td>

        <td width="81">Procedure&nbsp

            <p>PaintOval(r:Rect)</p>
        </td>

        <td width="106">Procedure Paint Round Rect(r:Rect; ovalWidth, ovalHeight:Integer)</td>

        <td width="97">Procedure PaintArc (r:Rect;startAngle, arcAngle:Integer)</td>
    </tr>

    <tr>
        <td width="48">
            Erase
        </td>

        <td width="81">Procedure&nbsp

            <p>EraseRect(r:Rect)</p>
        </td>

        <td width="81">Procedure&nbsp

            <p>EraseOval(r:Rect)</p>
        </td>

        <td width="106">Procedure Erase Round Rect(r:Rect; oval Width, ovalHeight:Integer)</td>

        <td width="97">Procedure EraseArc (r:Rect;startAngle, arcAngle:Integer)</td>
    </tr>

    <tr>
        <td width="48">
            Invert
        </td>

        <td width="81">Procedure&nbsp

            <p>InvertRect(r:Rect)</p>
        </td>

        <td width="81">Procedure&nbsp

            <p>InvertOval(r:Rect)</p>
        </td>

        <td width="106">Procedure Invert Round Rect(r:Rect; ovalWidth, ovalHeight:Integer)</td>

        <td width="97">Procedure InvertArc (r:Rect;startAngle, arcAngle:Integer)</td>
    </tr>

    <tr>
        <td width="48">
            Fill
        </td>

        <td width="81">Procedure&nbsp

            <p>FillRect(r:Rect
                <br>pat:Pattern)</p>
        </td>

        <td width="81">Procedure&nbsp

            <p>FillOval(r:Rect
                <br>pat:Pattern)</p>
        </td>

        <td width="106">Procedure FillRound Rect(r:Rect; ovalWidth, ovalHeight:Integer
            <br>pat:Pattern)</td>

        <td width="97">Procedure FillArc (r:Rect;startAngle, arcAngle:Integer
            <br>pat:Pattern)</td>
    </tr>
</table>

<h3>Spiral Pattern</h3>

<pre>
program Pattern;

  {Program to build spiral pattern, using}
  {relative line routine in a recursive loop}

 var
  sign: integer;

 procedure Spiral (x, y, sign: integer);

  {Procedure to spiral into limbo}

  var
   temp: integer;

 begin

  sign := (-1) * sign;
  if (abs(x) < 10) and (abs(y) < 10) then
   halt {Done recurring - ground case}
  else {Spiral still sizable}
   begin

    line(x, y); {Plot relative line}

  {Reduce magnitude of relative move by 5 pixels}

    if abs(x) > abs(y) then
     x := x - (x div abs(x) * 5)
    else
     y := y - (y div abs(y) * 5);

  {Exchange x<--> y}

    temp := x;
    x := y;
    y := temp;

  {On even calls, change sign}

    x := sign * x;
    y := sign * y;
    Spiral(x, y, sign); {Recur}
   end;

 end;

begin

 sign := 1;
 PenSize(9, 9);
 ShowDrawing;
 MoveTo(20, 20);
 Spiral(200, 0, -1);

end.
</pre>

<h3>Basics</h3>

<pre>
program Hello;
  {Comment}
begin
  writeln ('Hello, world.');
  readln;
end.
</pre>

<h3>Constants</h3>

<pre>
program const_circle (input,output);

const
PI = 3.141592654;

var
r, d, c : real;   {variable declaration: radius, dia, circumference}

begin
  writeln('Enter the radius of the circle');
  readln(r);

  d := 2 * r;
  c :=  PI * d;
  writeln('The circumference of the circle is ',c:7:2);
end.
</pre>

<h3>Hello World</h3>

<pre>
program Greetings;
  {A comment}
  const
  message = ' Welcome to the world of Pascal ';

  type
  name = string;

  var
  firstname, surname: name;
begin
   writeln('Please enter your first name: ');
   readln(firstname);

   writeln('Please enter your surname: ');
   readln(surname);

   writeln;
   writeln(message, ' ', firstname, ' ', surname);
end.
</pre>

<h3>Hello World(OS7)</h3>

<pre>
program Test;

  var
  w: WindowPtr; {A window to draw in}
  r: Rect; {The bounding box of the window}

begin

  {Create the window}
  SetRect(r, 50, 50, 200, 100);
  w := NewWindow(nil, r, '', true, plainDBox, WindowPtr(-1), false, 0);

  {Make it the current drawing port}
  SetPort(w);

  {Draw a string!}
  MoveTo(5, 20);
  DrawString('Hello world!');

  {Wait for a mouse-click, then stop.}
  while not Button do
  ;

end. 
</pre>

<h3>Button Events</h3>

<table border='1'>
    <tr>
        <td width="48">
            Object
        </td>

        <td width="116">
            Pascal Syntax
        </td>

        <td width="104">
            Example Call
        </td>

        <td width="166">
            Description
        </td>
    </tr>

    <tr>
        <td width="48">
            Button
        </td>

        <td width="106">Function Button:Boolean</td>

        <td width="94">if Button then <font face="Symbol">º&nbsp

            <p>else<font face="Symbol">º
            </p>
        </td>

        <td width="166">The Button function returns <i>True</i> if
the mouse button is down; <i>False</i> otherwise</td>
    </tr>

    <tr>
        <td width="48">
            Button
        </td>

        <td width="106">Function StillDown: Boolean</td>

        <td width="94">if StillDown then<font face="Symbol">º&nbsp

            <p>else<font face="Symbol">º
            </p>
        </td>

        <td width="166">Returns <i>True</i> if the button is still
down from the original press; <i>False</i> if it has been released or released
and repressed (i.e., mouse event on event queue)</td>
    </tr>

    <tr>
        <td width="48">
            Button
        </td>

        <td width="106">Function WaitMouseUp:Boolean</td>

        <td width="94">if WaitMouseUp then<font face="Symbol">º&nbsp

            <p>else<font face="Symbol">º
            </p>
        </td>

        <td width="166">Same as StillDown, but removes previous mouse
event from queue before returning False</td>
    </tr>

    <tr>
        <td width="48">
            Mouse cursor
        </td>

        <td width="106">Procedure GetMouse(<b>var</b> mouseLoc:point)</td>

        <td width="94">GetMouse(p);</td>

        <td width="166">Returns the present mouse cursor position
in local coordinates as a Point type</td>
    </tr>

    <tr>
        <td width="48">
            Keyboard
        </td>

        <td width="106">Procedure GetKeys(<b>var</b> theKeys:KeyMap)</td>

        <td width="94">GetKeys(key);</td>

        <td width="166">Reads the current state of the keyboard and
returns a keyMap, a Packed Array[1..127] of Boolean</td>
    </tr>

    <tr>
        <td width="48">
            Clock
        </td>

        <td width="106">Function TickCount:LongInt</td>

        <td width="94">if TickCount&lt;60 then<font face="Symbol">º
        </td>

        <td width="166">Returns the elapsed time in ticks (1/60th
sec) since last TickCount call</td>
    </tr>

    <tr>
        <td width="48">
            Event
        </td>

        <td width="106">Function GetNextEvent&nbsp

            <p>(eventMask:Integer;<b>var</b> theEvent:EventRecord): Boolean</p>
        </td>

        <td width="94">if GetNextEvent(2,Rec)&nbsp

            <p>then<font face="Symbol">º&nbsp

            </p>
            <p>else<font face="Symbol">º
            </p>
        </td>

        <td width="166">A logical function which returns <i>True</i>
if an event of the requested type exists on the event queue; <i>False</i>
otherwise. If <i>True</i>, it also returns a descriptive record of the
event. (type, location, time, conditions, etc)</td>
    </tr>
</table>

<pre>
program ButtonEvents;
{Program to demonstrate detection of button events }
{and use of button for program control. }

 var
  tic1, tic2: longint;

begin

    {Open Drawing Window and label screen.}
 ShowDrawing;
 MoveTo(20, 20);
 TextSize(18);
 WriteDraw('Button Event Test');
 MoveTo(35, 40);
 TextSize(12);

 WriteDraw('Double-Click to QUIT');
 MoveTo(40, 70);
 WriteDraw('Now the Button is: ');

    {Use XOR pattern to erase and rewrite output}
 TextMode(srcXor);
 MoveTo(80, 100);
 TextSize(24);
 TextFace([bold]);

 repeat {Until we double-click}
  while button do {Button down message detector}
   begin
    WriteDraw('down');
    MoveTo(80, 100);
    repeat {Tight loop until button up}
    until not Button;
    WriteDraw('down'); {Erase "down" text}
    MoveTo(80, 100);
    tic1 := TickCount; {Sample system clock: }
   end; {1/60 sec ticks}

  while not button do { Button up message detector}
   begin
    WriteDraw('up');
    MoveTo(80, 100);
    repeat {Tight loop until button down}
    until button;
    WriteDraw('up'); {Erase "up" text}
    MoveTo(80, 100);
    tic2 := TickCount; {Sample system clock}
   end;

 until abs(tic2 - tic1) < 30; {Double click message detector}

end.
</pre>

<h3>Drawing Program</h3>

<pre>
program RubberBand;

{Program to demonstrate Rubber Band technique}
{for constructing graphical objects }
 var
  x1, y1, x2, y2: integer;
  p: point;
begin

 ShowDrawing; {Open Drawing Window}
 MoveTo(20, 20); {Label graph and options}
 TextSize(18);
 WriteDraw('Rubber Band Program');
 TextSize(10);
 MoveTo(30, 40);
 WriteDraw('* Button down to draw line');
 MoveTo(30, 50);
 WriteDraw('* Double-click left of window to QUIT');
 PenMode(patXor); {Set Pen Mode to Xor}
    {to erase and redraw line}
 repeat {Keep working until exit}
  if Button then {executes once/line}
   begin
    GetMouse(p); {Read first point on line}
    x1 := p.h; {horizontal element of point}
    y1 := p.v;
{ vertical element of point }
    while Button do {Loop until button released}
     begin
      GetMouse(p); {Read second point}
      x2 := p.h; {horizontal element}
      y2 := p.v;
{ vertical element }
      DrawLine(x1, y1, x2, y2); {Draw line}
      DrawLine(x1, y1, x2, y2); {Erase line}
     end; {Now redraw permanent line }

    DrawLine(x1, y1, x2, y2);
   end;

 until (x1 < 0) and Button {Exit by clicking left}

end. {of Drawing Window}
</pre>