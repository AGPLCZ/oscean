<p>The Runtime.lib library contains all standard Pascal routines such as <code>writeln</code> and <code>sqrt</code>. The Interface.lib library contains the "glue code" for all Macintosh Toolbox. Since routines from these two libraries are commonly used in almost all Pascal programs on the Macintosh, they are automatically included in the project file.</p>

<pre>
  program Hello;

  {Comment}

  var
  name: string;

  begin

  name := 'alice';
  if (name = 'alice') then
  writeln('The name is alice.')
  else if (a = 'bob') then
  writeln('The name is bob.')
  else
  writeln('The name is not alice nor bob.');

  end.
</pre>

<h3>Creating a procedure</h3>

<p>A procedure definition in Pascal consists of a header, local declarations and a body of the procedure. The procedure header consists of the keyword procedure and a name given to the procedure. A procedure does not return anything.</p>

<pre>
  program ExampleProcedure;

  procedure Tri (x, y, side: integer);
  begin
  MoveTo(x, y);
  LineTo(x + side, y);
  LineTo(x + side div 2, Round(y + Side / Sqrt(2)));
  LineTo(x, y);
  end;

  begin
  Tri(10, 10, 100);
  Tri(40, 40, 80);
  Tri(80, 85, 180);
  end.
</pre>

<h3>Creating a function</h3>

<p>A function declaration tells the compiler about a function's name, return type, and parameters. A function definition provides the actual body of the function.</p>

<pre>
  program ExampleFunction;

  function add (a, b: integer): integer;
  begin
  add := a + b;
  end;

  begin
  writeln('5+6=', add(5, 6));
  end.
</pre>

<h3>Creating a type</h3>

<p>An Object is a special kind of record that contains fields like a record; however, unlike records, objects contain procedures and functions as part of the object. These procedures and functions are held as pointers to the methods associated with the object's type.</p>

<pre>
  program Example;

  type
  Rectangle = object
  width, height: integer;
  end;
  var
  r1: Rectangle;

  begin

  new(r1);
  r1.width := 12;
  r1.height := 34;
  writeln('The rect is ', r1.width, 'x', r1.height);

  end.
</pre>

<h3>Creating a type with a method</h3>

<pre>
  program Example;

  type
  Rectangle = object
  width, height: integer;
  procedure setwidth (w: integer);
  end;

  var
  r1: Rectangle;

  procedure Rectangle.setwidth (w: integer);
  begin
  width := w;
  end;

  begin

  new(r1);
  r1.width := 12;
  r1.height := 34;
  writeln('The rect was ', r1.width, ' x ', r1.height);
  r1.setWidth(56);
  writeln('The rect is now ', r1.width, ' x ', r1.height);

  end.
</pre>

<p>Think Pascal is a development system for the Macintosh, released by Think Technologies in 1986 as Lightspeed Pascal. Think Technologies was bought by Symantec, and the name was changed to Think Pascal. The last official update came 1992, and the product was officially discontinued in 1997.</p>

<h3>Console Program</h3>

<pre>
  program Greetings;

  const
  message = ' Welcome to the world of Pascal ';

  type
  name = string;

  var
  firstname, surname: name;

  begin

  writeln('Please enter your first name: ');
  readln(firstname);

  writeln('Please enter your surname: ');
  readln(surname);

  writeln;
  writeln(message, ' ', firstname, ' ', surname);

  end.
</pre>

<h3>GUI Program</h3>

<pre>
  program Test;

  var
  w: WindowPtr; {A window to draw in}
  r: Rect; {The bounding box of the window}

  begin

  {Create the window}
  SetRect(r, 50, 50, 200, 100);
  w := NewWindow(nil, r, '', true, plainDBox, WindowPtr(-1), false, 0);

  {Make it the current drawing port}
  SetPort(w);

  {Draw a string!}
  MoveTo(5, 20);
  DrawString('Hello world!');

  {Wait for a mouse-click, then stop.}
  while not Button do
  ;

  end.
</pre>

<h3>Graphics Primitives</h3>

<p>Graphical user interface design rests firmly on the foundation of OOP and illustrates its power and elegance. </p>

<table border='1'>
  <tr>
    <td>Object</td>
    <td>Pascal</td>
    <td>Description</td>
  </tr>
  <tr>
    <td>Pen</td>
    <td>PenSize(width, height:INTEGER)</td>
    <td>Sets the size of the plotting pen, in pixels</td>
  </tr>
  <tr>
    <td>Pen- move absolute</td>
    <td>MoveTo(h,v: INTEGER)</td>
    <td>Moves pen (invisibly) to pixel (h,v) (absolute coordinates)</td>
  </tr>
  <tr>
    <td>Pen- move relative</td>
    <td>Move(dh,dv: INTEGER)</td>
    <td>Moves pen (invisibly) dh pixels horizontally and dv pixels vertically (relative coordinates)</td>
  </tr>
  <tr>
    <td>Point</td>
    <td>DrawLine(x1,y1, x1,y1:INTEGER)</td>
    <td>Draws a line from point (x1,y1) to the second point, (x1,y1), i.e. a point</td>
  </tr>
  <tr>
    <td>Point</td>
    <td>MoveTo(x1,y1: INTEGER) <p>Procedure LineTo(x1,y1: INTEGER)</p></td>
    <td>Moves to pixel (x1,y1) and draws a line to (x1,y1), i.e. a point</td>
  </tr>
  <tr>
    <td>Point</td>
    <td>Line(dx,dy: INTEGER)</td>
    <td>From the present position of the pen, draw a line a distance (0,0)</td>
  </tr>
  <tr>
    <td>Line - absolute</td>
    <td>DrawLine(x1,y1, x2,y2:INTEGER)</td>
    <td>Draws a line from point (x1,y1) to the second point, (x2,y2)</td>
  </tr>
  <tr>
    <td>Line - absolute</td>
    <td>MoveTo(x1,y1: INTEGER) <p>Procedure LineTo(x2,y2: INTEGER)</p></td>
    <td>Moves to pixel (x1,y1) and draws a line to (x2,y2)</td>
  </tr>
  <tr>
    <td>Line - relative</td>
    <td>Line(dx,dy: INTEGER)</td>
    <td>Draw a line a distance (dx,dy) relative to the present pen position</td>
  </tr>
  <tr>
    <td>Text</td>
    <td>WriteDraw(p1 [,p2Ö, pn])</td>
    <td>The WriteLn equivalent procedure for the drawing window</td>
  </tr>
  <tr>
    <td>Drawing Window</td>
    <td>Procedure ShowDrawing</td>
    <td>Opens the Drawing Window</td>
  </tr>
</table>

<h3>Graphic Primitives Example</h3>

<pre>
  program Primitives;

  {Program to demonstrate Pascal point & line primitives.}

  begin

  ShowDrawing; {Opens Drawing Window}

  {First draw three points by three different functions}

  PenSize(1, 1); {Sets pen size to 1 x 1 pixels}
  DrawLine(50, 50, 50, 50);
  WriteDraw(' Point at (50,50) using DrawLine');

  PenSize(2, 2);
  MoveTo(100, 75); {Absolute move}
  LineTo(100, 75);
  WriteDraw(' Point at (100,75) using LineTo');

  PenSize(3, 3);
  MoveTo(150, 100); {Absolute move}
  Line(0, 0);
  WriteDraw(' Point at (150,100) using Line');

  {Now Draw three lines by three different functions}

  MoveTo(150, 175); {Absolute move}
  WriteDraw('Line drawn with DrawLine');
  DrawLine(150, 125, 50, 225);

  PenSize(2, 2);
  Move(0, 25); {Relative move}
  LineTo(150, 250);
  WriteDraw('Line drawn by LineTo');

  Pensize(1, 1);
  Move(0, 25); {Relative move}
  Line(-100, 50);
  WriteDraw('Line drawn by Line');

  end.
</pre>

<h3>Graphics Primitives - Geometric Figures</h3>

<table border='1'>
  <tr>
    <td width="48"></td>
    <td width="90">Rectangles<br />(Squares)</td>
    <td width="90">Ovals<br />(Circles)</td>
    <td width="106">Rounded-Corner<br />Rectangles</td>
    <td width="97">Arcs and<br />Wedges</td>
  </tr>
  <tr>
    <td width="48">Frame</td>
    <td width="81">ProcedureFrameRect(r:Rect)</td>
    <td width="81">ProcedureFrameOval(r:Rect)</td>
    <td width="106">Frame Round Rect (r:Rect; ovalWidth, ovalHeight:Integer)</td>
    <td width="97">FrameArc (r:Rect;startAngle, arcAngle:Integer)</td>
  </tr>
  <tr>
    <td width="48">Paint</td>
    <td width="81">PaintRect(r:Rect)</td>
    <td width="81">PaintOval(r:Rect)</td>
    <td width="106">Paint Round Rect(r:Rect; ovalWidth, ovalHeight:Integer)</td>
    <td width="97">PaintArc (r:Rect;startAngle, arcAngle:Integer)</td>
  </tr>
  <tr>
    <td width="48">Erase</td>
    <td width="81">EraseRect(r:Rect)</td>
    <td width="81">EraseOval(r:Rect)</td>
    <td width="106">Erase Round Rect(r:Rect; oval Width, ovalHeight:Integer)</td>
    <td width="97">EraseArc (r:Rect;startAngle, arcAngle:Integer)</td>
  </tr>
  <tr>
    <td width="48">Invert</td>
    <td width="81">InvertRect(r:Rect)</td>
    <td width="81">InvertOval(r:Rect)</td>
    <td width="106">Invert Round Rect(r:Rect; ovalWidth, ovalHeight:Integer)</td>
    <td width="97">InvertArc (r:Rect;startAngle, arcAngle:Integer)</td>
  </tr>
  <tr>
    <td width="48">Fill</td>
    <td width="81">FillRect(r:Rect, pat:Pattern)</td>
    <td width="81">FillOval(r:Rect,pat:Pattern)</td>
    <td width="106">FillRound Rect(r:Rect; ovalWidth, ovalHeight:Integer, pat:Pattern)</td>
    <td width="97">FillArc (r:Rect;startAngle, arcAngle:Integer, pat:Pattern)</td>
  </tr>
</table>

<h3>Spiral Pattern</h3>

<pre>
  program Pattern;

  {Program to build spiral pattern, using}
  {relative line routine in a recursive loop}

  var
  sign: integer;

  procedure Spiral (x, y, sign: integer);

  {Procedure to spiral into limbo}

  var
  temp: integer;

  begin

  sign := (-1) * sign;
  if (abs(x) < 10) and (abs(y) < 10) then
  halt {Done recurring - ground case}
  else {Spiral still sizable}
  begin

  line(x, y); {Plot relative line}

  {Reduce magnitude of relative move by 5 pixels}

  if abs(x) > abs(y) then
  x := x - (x div abs(x) * 5)
  else
  y := y - (y div abs(y) * 5);

  {Exchange x<--> y}

  temp := x;
  x := y;
  y := temp;

  {On even calls, change sign}

  x := sign * x;
  y := sign * y;
  Spiral(x, y, sign); {Recur}
  end;

  end;

  begin

  sign := 1;
  PenSize(9, 9);
  ShowDrawing;
  MoveTo(20, 20);
  Spiral(200, 0, -1);

  end.
</pre>

<h3>Button Events</h3>

<table border='1'>
  <tr>
    <td width="48">Object</td>
    <td width="116">Pascal Syntax</td>
    <td width="104">Example Call</td>
    <td width="166">Description</td>
  </tr>
  <tr>
    <td width="48">Button
    </td>
    <td width="106">Function Button:Boolean</td>
    <td width="94">if Button then º<br/>elseº</td>
    <td width="166">The Button function returns <i>True</i> if the mouse button is down; <i>False</i> otherwise</td>
  </tr>
  <tr>
    <td width="48">Button</td>
    <td width="106">Function StillDown: Boolean</td>
    <td width="94">if StillDown thenº<br />elseº</p></td>
    <td width="166">Returns <i>True</i> if the button is still down from the original press; <i>False</i> if it has been released or released and repressed (i.e., mouse event on event queue)</td>
  </tr>
  <tr>
    <td width="48">Button</td>
    <td width="106">Function WaitMouseUp:Boolean</td>
    <td width="94">if WaitMouseUp thenº<br />elseº</p>
    </td>
    <td width="166">Same as StillDown, but removes previous mouse event from queue before returning False</td>
  </tr>
  <tr>
    <td width="48">Mouse cursor</td>
    <td width="106">GetMouse(<b>var</b> mouseLoc:point)</td>
    <td width="94">GetMouse(p);</td>
    <td width="166">Returns the present mouse cursor position in local coordinates as a Point type</td>
  </tr>
  <tr>
    <td width="48">Keyboard</td>
    <td width="106">GetKeys(<b>var</b> theKeys:KeyMap)</td>
    <td width="94">GetKeys(key);</td>
    <td width="166">Reads the current state of the keyboard and returns a keyMap, a Packed Array[1..127] of Boolean</td>
  </tr>
  <tr>
    <td width="48">Clock</td>
    <td width="106">Function TickCount:LongInt</td>
    <td width="94">if TickCount&lt;60 thenº</td>
    <td width="166">Returns the elapsed time in ticks (1/60th sec) since last TickCount call</td>
  </tr>
  <tr>
    <td width="48">Event</td>
    <td width="106">Function GetNextEvent<br/><p>(eventMask:Integer;<b>var</b> theEvent:EventRecord): Boolean</p></td>
    <td width="94">if GetNextEvent(2,Rec)<br/><p>thenº<br/></p><p>elseº</p></td>
    <td width="166">A logical function which returns <i>True</i> if an event of the requested type exists on the event queue; <i>False</i> otherwise. If <i>True</i>, it also returns a descriptive record of the event. (type, location, time, conditions, etc)</td>
  </tr>
</table>

<h3>Drawing Program</h3>

<pre>
  program RubberBand;

  {Program to demonstrate Rubber Band technique}
  {for constructing graphical objects }
  var
  x1, y1, x2, y2: integer;
  p: point;
  begin

  ShowDrawing; {Open Drawing Window}
  MoveTo(20, 20); {Label graph and options}
  TextSize(18);
  WriteDraw('Rubber Band Program');
  TextSize(10);
  MoveTo(30, 40);
  WriteDraw('* Button down to draw line');
  MoveTo(30, 50);
  WriteDraw('* Double-click left of window to QUIT');
  PenMode(patXor); {Set Pen Mode to Xor}
  {to erase and redraw line}
  repeat {Keep working until exit}
  if Button then {executes once/line}
  begin
  GetMouse(p); {Read first point on line}
  x1 := p.h; {horizontal element of point}
  y1 := p.v;
  { vertical element of point }
  while Button do {Loop until button released}
  begin
  GetMouse(p); {Read second point}
  x2 := p.h; {horizontal element}
  y2 := p.v;
  { vertical element }
  DrawLine(x1, y1, x2, y2); {Draw line}
  DrawLine(x1, y1, x2, y2); {Erase line}
  end; {Now redraw permanent line }

  DrawLine(x1, y1, x2, y2);
  end;

  until (x1 < 0) and Button {Exit by clicking left}

  end. {of Drawing Window}
</pre>

<h3>Notes</h3>

<p>A semi-colon is not required after the last statement of a block, adding one adds a "null statement" to the program, which is ignored by the compiler.</p>

<p>The programmer has the freedom to define other commonly used data types (e.g. byte, string, etc.) in terms of the predefined types using Pascal's type declaration facility, for example:</p>

<pre>
  type
  byte        = 0..255;
  signed_byte = -128..127;
  string      = packed array[1..255] of char;
</pre>

<p>If you are using decimal (real type) numbers, you can specify the number of decimal places to show with an additional colon:</p>

<pre>writeln(52.234567:1:3);</pre>

<p>The 'whole number' part of the real number is displayed as is, no matter whether it exceeds the first width (in this case 1) or not, but the decimal part is truncated to the number of decimal places specified in the second width. The previous example will result in 52.234 being written.</p>

<h3>Patterns</h3>

<p>The available patterns are:</p>

<ul>
  <li>black</li>
  <li>dkgray</li>
  <li>gray</li>
  <li>ltgray</li>
  <li>white</li>
</ul>

<p>The following Think Pascal commands will be useful to you in writing interactive graphics programs on the Macintosh.  They are listed by type:</p>

<h3>Window Commands</h3>

<table border='1'>
  <tr><td>ShowDrawing</td><td>Open the drawing window (if not already open) and make it the active window on the screen.  Should be used when first draw to drawing window and anytime shift from text to drawing window.</td></tr>
  <tr><td>ShowText</td><td>Similarly for the text window.</td></tr>
  <tr><td>HideAll</td><td>Closes all Think Pascal windows on the screen.</td></tr>
  <tr><td>SetDrawingRect(WindowRect)</td><td>Set Drawing Window to fit WindowRect</td></tr>
  <tr><td>SetTextRect(WindowRect)</td><td>Set Text Window to fit WindowRect</td></tr>
</table>

<h3>Writing words on the screen:</h3>

<table border='1'>
  <tr><td>Writeln('text')</td><td>Prints  text to the Text Window and moves cursor to next line.</td></tr>
  <tr><td>Writeln(integer)</td><td>Prints  integer in the Text Window and moves cursor to next line.</td></tr>
  <tr><td>Writeln(integer : d )</td><td>Prints  integer in the Text Window using at least  d spaces and then moves cursor to next line.</td></tr>
  <tr><td>Write('text')</td><td>Prints  text to the Text Window but does not move cursor to next line.</td></tr>
  <tr><td>WriteDraw('text')</td><td>Prints  text to the Drawing Window, starting at the CP.  The CP is left at the lower right corner of the last character drawn.</td></tr>
</table>

<h3>Builtin Types</h3>

<table border='1'>
  <tr><td><i>Type</i></td><td><i>Records</i></td></tr>
  <tr><td>Rect</td><td>left, top, right, bottom : integer</td></tr>
  <tr><td>Point</td><td>h, v : intege</td></tr>
</table>

<h3>Builtin Procedures</h3>

<table border='1'>
  <tr><td>SetPt(VAR pt : Point; h,v : INTEGER)</td><td>Make point,  pt,with coords  (h,v)</td></tr>
  <tr><td>SetRect(VAR r : Rect; left, top, right, bottom : INTEGER)</td><td>Make rectangle with coords  (left,top) and  (right,bottom) as corners.</td></tr>
  <tr><td>offsetRect(VAR r : Rect; left, top : INTEGER)</td><td>Change rectangle to coords (left,top).</td></tr>
  <tr><td>insetRect(VAR r : Rect; right, bottom : INTEGER)</td><td>Change rectangle to coords (left,top).</td></tr>
  <tr><td>Pt2Rect( pt1, pt2 : Point; dstRect : Rect);</td><td>Make rectangle with  pt1 and  pt2 as corners</td></tr>
  <tr><td>PtInRect(pt:Point; r : Rect) : BOOLEAN;</td><td>Determine if pt is in the rectangle r.</td></tr>
</table>

<h1>Summary of QuickDraw Drawing</h1>
<pre>
  srcCopy        = 0;  {where source pixel is black, force destination }
  { pixel black; where source pixel is white, force }
  { destination pixel white}
  srcOr          = 1;  {where source pixel is black, force destination }
  { pixel black; where source pixel is white, leave }
  { destination pixel unaltered}
  srcXor         = 2;  {where source pixel is black, invert destination }
  { pixel; where source pixel is white, leave }
  { destination pixel unaltered}
  srcBic         = 3;  {where source pixel is black, force destination }
  { pixel white; where source pixel is white, leave }
  { destination pixel unaltered}
  notSrcCopy     = 4;  {where source pixel is black, force destination }
  { pixel white; where source pixel is white, force }
  { destination pixel black}
  notSrcOr       = 5;  {where source pixel is black, leave destination }
  { pixel unaltered; where source pixel is white, }
  { force destination pixel black}
  notSrcXor      = 6;  {where source pixel is black, leave destination }
  { pixel unaltered; where source pixel is white, }
  { invert destination pixel}
  notSrcBic      = 7;  {where source pixel is black, leave destination }
  { pixel unaltered; where source pixel is white, }
  { force destination pixel white}

  {pattern modes}
  patCopy        = 8;  {where pattern pixel is black, apply foreground }
  { color to destination pixel; where pattern pixel }
  { is white, apply background color to destination }
  { pixel}
  patOr          = 9;  {where pattern pixel is black, invert destination }
  { pixel; where pattern pixel is white, leave }
  { destination pixel unaltered}
  patXor         = 10; {where pattern pixel is black, invert destination }
  { pixel; where pattern pixel is white, leave }
  { destination pixel unaltered}
  patBic         = 11; {where pattern pixel is black, apply background }
  { color to destination pixel; where pattern pixel }
  { is white, leave destination pixel unaltered}
  notPatCopy     = 12; {where pattern pixel is black, apply background }
  { color to destination pixel; where pattern pixel }
  { is white, apply foreground color to destination }
  { pixel}
  notPatOr       = 13; {where pattern pixel is black, leave destination }
  { pixel unaltered; where pattern pixel is white, }
  { apply foreground color to destination pixel}
  notPatXor      = 14; {where pattern pixel is black, leave destination }
  { pixel unaltered; where pattern pixel is white, }
  { invert destination pixel}
  notPatBic      = 15; {where pattern pixel is black, leave destination }
  { pixel unaltered; where pattern pixel is white, }
  { apply background color to destination pixel}
  ditherCopy     = 64; {add to source mode for dithering}
</pre>

<h3>Routines</h3>
<h4>Managing the Graphics Pen</h4>

<pre>PROCEDURE HidePen;
  PROCEDURE ShowPen;
  PROCEDURE GetPen        (VAR pt: Point);
  PROCEDURE GetPenState   (VAR pnState: PenState);
  PROCEDURE SetPenState   (pnState: PenState);
  PROCEDURE PenSize       (width,height: Integer);
  PROCEDURE PenMode       (mode: Integer);
  PROCEDURE PenPat        (pat: Pattern);
  PROCEDURE PenNormal;
</pre>

<h4>Changing the Background Bit Pattern</h4>
<pre>PROCEDURE BackPat       (pat: Pattern); 
</pre>

<h4>Drawing Lines</h4>
<pre>PROCEDURE MoveTo        (h,v: Integer);
  PROCEDURE Move          (dh,dv: Integer);
  PROCEDURE LineTo        (h,v: Integer);
  PROCEDURE Line          (dh,dv: Integer);
</pre>

<h4>Creating and Managing Rectangles</h4>
<pre>PROCEDURE SetRect       (VAR r: Rect; left,top,right,bottom: Integer);
PROCEDURE OffsetRect    (VAR r: Rect; dh,dv: Integer);
PROCEDURE InsetRect     (VAR r: Rect; dh,dv: Integer);
PROCEDURE UnionRect     (src1,src2: Rect; VAR dstRect: Rect);
PROCEDURE Pt2Rect       (pt1,pt2: Point; VAR dstRect: Rect);
PROCEDURE PtToAngle     (r: Rect; pt: Point; VAR angle: Integer);
FUNCTION SectRect       (src1,src2: Rect; VAR dstRect: Rect): Boolean;
FUNCTION PtInRect       (pt: Point; r: Rect): Boolean;
FUNCTION EqualRect      (rect1,rect2: Rect): Boolean;
FUNCTION EmptyRect      (r:  Rect): Boolean;
</pre>

<h4>Drawing Rectangles</h4>
<pre>PROCEDURE FrameRect     (r: Rect);
  PROCEDURE PaintRect     (r: Rect);
  PROCEDURE FillRect      (r: Rect; pat: Pattern);
  PROCEDURE EraseRect     (r: Rect);
  PROCEDURE InvertRect    (r: Rect);
</pre>

<h4>Drawing Rounded Rectangles</h4>
<pre>PROCEDURE FrameRoundRect  (r: Rect; ovalWidth,ovalHeight: Integer);
  PROCEDURE PaintRoundRect  (r: Rect; ovalWidth,ovalHeight: Integer);
  PROCEDURE FillRoundRect   (r: Rect; ovalWidth,ovalHeight: Integer; pat: Pattern);
  PROCEDURE EraseRoundRect  (r: Rect; ovalWidth,ovalHeight: Integer);
  PROCEDURE InvertRoundRect (r: Rect; ovalWidth,ovalHeight: Integer);
</pre>

<h4>Drawing Ovals</h4>
<pre>PROCEDURE FrameOval     (r: Rect);
  PROCEDURE PaintOval     (r: Rect);
  PROCEDURE FillOval      (r: Rect; pat: Pattern);
  PROCEDURE EraseOval     (r: Rect);
  PROCEDURE InvertOval    (r: Rect);
</pre>

<h4>Drawing Arcs and Wedges</h4>
<pre>PROCEDURE FrameArc      (r: Rect; startAngle,arcAngle: Integer);
  PROCEDURE PaintArc      (r: Rect; startAngle,arcAngle: Integer);
  PROCEDURE FillArc       (r: Rect; startAngle,arcAngle: Integer; pat: Pattern);
  PROCEDURE EraseArc      (r: Rect; startAngle,arcAngle: Integer);
  PROCEDURE InvertArc     (r: Rect; startAngle,arcAngle: Integer);
</pre>

<h4>Creating and Managing Polygons</h4>
<pre>FUNCTION OpenPoly  : PolyHandle;
  PROCEDURE ClosePoly;
  PROCEDURE OffsetPoly    (poly: PolyHandle; dh,dv: Integer);
  PROCEDURE KillPoly      (poly: PolyHandle);
</pre>

<h4>Drawing Polygons</h4>
<pre>PROCEDURE FramePoly     (poly: PolyHandle);
  PROCEDURE PaintPoly     (poly: PolyHandle);
  PROCEDURE FillPoly      (poly: PolyHandle; pat: Pattern);
  PROCEDURE ErasePoly     (poly: PolyHandle);
  PROCEDURE InvertPoly    (poly: PolyHandle);
</pre>

<h4>Creating and Managing Regions</h4>
<pre>FUNCTION NewRgn : RgnHandle;
  PROCEDURE OpenRgn;
  PROCEDURE CloseRgn      (dstRgn: rgnHandle);
  PROCEDURE DisposeRgn    (rgn: RgnHandle);
  PROCEDURE CopyRgn       (srcRgn,dstRgn: RgnHandle);
  PROCEDURE SetEmptyRgn   (rgn: RgnHandle);
  PROCEDURE SetRectRgn    (rgn: RgnHandle; left,top,right,bottom: Integer);
  PROCEDURE RectRgn       (rgn: RgnHandle; r: Rect);
  PROCEDURE OffsetRgn     (rgn: RgnHandle; dh,dv: Integer);
  PROCEDURE InsetRgn      (rgn: RgnHandle; dh,dv: Integer);
  PROCEDURE SectRgn       (srcRgnA,srcRgnB,dstRgn: RgnHandle);
  PROCEDURE UnionRgn      (srcRgnA,srcRgnB,dstRgn: RgnHandle);
  PROCEDURE DiffRgn       (srcRgnA,srcRgnB,dstRgn: RgnHandle);
  PROCEDURE XorRgn        (srcRgnA,srcRgnB,dstRgn: RgnHandle);
  FUNCTION PtInRgn        (pt: Point; rgn: RgnHandle): Boolean;
  FUNCTION RectInRgn      (r: Rect; rgn: RgnHandle): Boolean;
  FUNCTION EqualRgn       (rgnA,rgnB: RgnHandle): Boolean;
  FUNCTION EmptyRgn       (rgn: RgnHandle): Boolean;
</pre>

<h4>Drawing Regions</h4>
<pre>PROCEDURE FrameRgn      (rgn: RgnHandle);
  PROCEDURE PaintRgn      (rgn: RgnHandle);
  PROCEDURE FillRgn       (rgn: RgnHandle; pat: Pattern);
  PROCEDURE EraseRgn      (rgn: RgnHandle);
  PROCEDURE InvertRgn     (rgn: RgnHandle);
</pre>

<h4>Scaling and Mapping Points, Rectangles, Polygons, and Regions</h4>
<pre>PROCEDURE ScalePt       (VAR pt: Point; srcRect,dstRect: Rect);
  PROCEDURE MapPt         (VAR pt: Point; srcRect,dstRect: Rect);
  PROCEDURE MapRect       (VAR r: Rect; srcRect,dstRect: Rect);
  PROCEDURE MapRgn        (rgn: RgnHandle; srcRect,dstRect: Rect);
  PROCEDURE MapPoly       (poly: PolyHandle; srcRect,dstRect: Rect);
</pre>

<h4>Calculating Black-and-White Fills</h4>
<pre>PROCEDURE SeedFill      (srcPtr,dstPtr: Ptr; srcRow,dstRow,height,words,seedH,seedV: Integer);
 PROCEDURE CalcMask      (srcPtr,dstPtr: Ptr; srcRow,dstRow,height,words: Integer);
</pre>

<h4>Copying Images</h4>
<pre>PROCEDURE CopyBits      (srcBits,dstBits: BitMap; srcRect,dstRect: Rect; mode: Integer; maskRgn: RgnHandle);
 PROCEDURE CopyMask      (srcBits,maskBits,dstBits: BitMap; srcRect,maskRect,dstRect: Rect);
 PROCEDURE CopyDeepMask  (srcBits: BitMap; maskBits: BitMap; dstBits: BitMap; srcRect: Rect; maskRect: Rect; dstRect: Rect; mode: Integer; maskRgn: RgnHandle);
</pre>

<h4>Drawing With the Eight-Color System</h4>

<pre>PROCEDURE ForeColor     (color: LongInt);
  PROCEDURE BackColor     (color: LongInt);
  PROCEDURE ColorBit      (whichBit: Integer);
</pre>

<h4>Determining Whether QuickDraw Has Finished Drawing</h4>
<pre>FUNCTION QDDone         (port: GrafPtr): Boolean;
</pre>

<h4>Getting Pattern Resources</h4>
<pre>FUNCTION GetPattern     (patID: Integer): PatHandle;
  PROCEDURE GetIndPattern (VAR thePattern: Pattern; patListID: Integer; index: Integer);
</pre>

<h4>Customizing QuickDraw Operations</h4>
<pre>PROCEDURE SetStdProcs   (VAR procs: QDProcs);
  PROCEDURE StdText       (byteCount: Integer; textBuf: Ptr; numer,denom: Point);
  PROCEDURE StdLine       (newPt: Point);
  PROCEDURE StdRect       (verb: GrafVerb; r: Rect);
  PROCEDURE StdRRect      (verb: GrafVerb; r: Rect; ovalwidth,ovalHeight: Integer);
  PROCEDURE StdOval       (verb: GrafVerb; r: Rect);
  PROCEDURE StdArc        (verb: GrafVerb; r: Rect; startAngle,arcAngle: Integer);
  PROCEDURE StdPoly       (verb: GrafVerb; poly: PolyHandle);
  PROCEDURE StdRgn        (verb: GrafVerb; rgn: RgnHandle);
  PROCEDURE StdBits       (VAR srcBits: BitMap; VAR srcRect,dstRect: Rect; mode: Integer; maskRgn: RgnHandle);
  PROCEDURE StdComment    (kind,dataSize: Integer; dataHandle: Handle);
  FUNCTION StdTxtMeas     (byteCount: Integer; textAddr: Ptr; VAR numer, denom: Point; VAR info: FontInfo): Integer;
  PROCEDURE StdGetPic     (dataPtr: Ptr; byteCount: Integer);
  PROCEDURE StdPutPic     (dataPtr: Ptr; byteCount: Integer);
</pre>