<p>The cpu does not have access to reading the rom itself, so the loaded rom needs to copy the data to the memory.</p>

<h3>Instructions</h3>

<p>Each instruction uses 4-bits for the operation, 4-bits for the addressing mode and 8-bits for the address. </p>

<table border='1'>
	<tr><td>0x0</td><td>BRK</td><td>Break</td></tr>
	<tr><td>0x1</td><td>JMP</td><td>Jump to position</td></tr>
	<tr><td>0x2</td><td>JEQ</td><td>Jump to position, when carry</td></tr>
	<tr><td>0x3</td><td>JNE</td><td>Jump to position, when not carry</td></tr>
	<tr><td>0x4</td><td>RME</td><td>Store in register from addr in memory</td></tr>
	<tr><td>0x5</td><td>RVA</td><td>Store in register from value</td></tr>
	<tr><td>0x6</td><td>MRE</td><td>Store in memory from register at value</td></tr>
	<tr><td>0x7</td><td>MVA</td><td>Store in memory from value at register</td></tr>
	<tr><td>0x8</td><td>ADD</td><td>Add value to register</td></tr>
	<tr><td>0x9</td><td>SUB</td><td>Substract value from register</td></tr>
	<tr><td>0xA</td><td>EQU</td><td>Compare, set carry when equal</td></tr>
	<tr><td>0xB</td><td>LES</td><td>Compare, set carry when less than</td></tr>
	<tr><td>0xC</td><td>CLC</td><td>Clear carry</td></tr>
	<tr><td>0xD</td><td>TEL</td><td>Store in register from register id</td></tr>
	<tr><td>0xE</td><td>SEL</td><td>Select register</td></tr>
	<tr><td>0xF</td><td>NOP</td><td>Do nothing</td></tr>
</table>

<p>The <b>addressing mode</b> bit is typically used to form a 12-bits address or to differenciate between a number, the value of a register and the value of an address in memory.</p>

<table border='1'>
	<tr><th>opcode</th><th>mode</th><th colspan="2">address</th><td>result</td></tr>
	<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>BRK</td></tr>
</table>

<h3>Gyo ASM</h3>

<p>The assembler syntax supports :label, ~const and =var.</p>

<pre>
; comment

~rate #01

; variables

=var1
=var2

; program 

:label
	SEL #00
	RVA #09
</pre>

<h3>Conditional</h3>

<p>The following example demonstrate how to do a conditional jump.</p>
<pre>
	SEL #00
	EQU #01         ; check if r0 is equal to r1
	JEQ there       ; if equal, goto There
:here
	MRE var1        ; write in addr$01
	BRK
:there
	MRE var2        ; write in addr$02
	BRK	
</pre>

<h3>Loop</h3>

<pre>
	RVA #02
	SEL #01         ; select r1
:loop
	EQU #00         ; set flag if r0 = r15
	SUB #01        ; subtract r0 by rate
	JNE loop        ; goto loop if not equal
	BRK
</pre>

<h3>Status Flags</h3>

<p>The status register is distributed as follows, it shares the same byte as the register selector. The <b>halt</b> flag is used by the BRK instruction is stops the cpu, the <b>zero</b> flag is used for conditional instructions(EQU/LES/JEQ/JNE), the <b>carry</b> flag is set when a SUB/ADD instruction carries over the 8bit range and the <b>traps</b> flag is set when the pointer should be sent to the traps location(in IO operations). 
</p>

<pre>
T C Z H
| | | +---- Halt
| | +------ Zero
| +-------- Carry
+---------- Traps
</pre>

<p>The carry flag is triggered when a ADD or SUB operation goes over the range of a char.</p>

<pre>
	SEL #00 ; select ,0
	RVA #FE ; store #EF
	ADD #02 ; add #02 carry flag is now 1
	CLC     ; clear flag
	RVA #00 ; store #01
	SUB #02 ; sub #02 carry flag is now 1
	CLC     ; clear flag
</pre>