Ø("invoke").seal("javascript",`
Geometry
  # 2 * π * R  = C
Math
  # {*clamp*}(v,min,max){ return v < min ? min : v > max ? max : v; }
  # {*step*}(v,step){ return parseInt(v/step) * step; }
Objects
  # {*is_json*}(s){ try{ JSON.parse(s); return true; } catch(e){ return false; }}
  # {*copy*}(o){ return JSON.parse(JSON.stringify(o)); }
  # {*uniq*}(a){ return a ? a.reduce((x,y) => { if(x.indexOf(y) < 0 ) x[x.length] = y; return x; },[]) : []; }
Geometry
  # {*distance*}(a,b){ return Math.sqrt( (a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y) ); }
  # {*rotate*}(point,origin,angle){ angle = angle * Math.PI/180.0; return { x: (Math.cos(angle) * (point.x-origin.x) - Math.sin(angle) * (point.y-origin.y) + origin.x).toFixed(1), y: (Math.sin(angle) * (point.x-origin.x) + Math.cos(angle) * (point.y-origin.y) + origin.y).toFixed(1) }; }
Map
  & {*Map*} will modify/add properties or run a function onto each object.
  # array.{*map*}((value,index,array) => { return value *2; })
Filter
  & {*Filter*} only keeps elements returning true.
  # array.{*filter*}((value,index,array) => { return value % 2 === 0; })
Reduce
  & {*Reduce*} takes an array and reduces it into a single value.
  # array.{*reduce*}((acc,value,index,array) => { return acc + value; },0)
Bitwise
  | AND | 5 & 1    | 1   
  | OR  | 5 &vert; 1    | 5   
  | XOR | ~ 5      | 10   
  | NOT | 5 << 1   | 10   
  | <<  | 5 ^ 1    | 4   
  | >>  | 5 >> 1   | 2   
  | >>> | 5 >>> 1  | 2
Examples:
  | 0 & 0 = 0 | 0 &vert; 0 = 0 | 0 ^ 0 = 0
  | 0 & 1 = 0 | 0 &vert; 1 = 1 | 0 ^ 1 = 1
  | 1 & 0 = 0 | 1 &vert; 0 = 1 | 1 ^ 0 = 1
  | 1 & 1 = 1 | 1 &vert; 1 = 1 | 1 ^ 1 = 0
`,Indental);
